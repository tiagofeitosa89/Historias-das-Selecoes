/ *! jQuery v1.12.4 | (c) Fundação jQuery | jquery.org/license * /
! function (a, b) {"objeto" == tipo de módulo && "objeto" == tipo de módulo module.exports? module.exports = a.document? b (a,! 0): function (a) {if (! a .document) throw new Erro ("jQuery requer uma janela com um documento"); return b (a)}: b (a)} (janela "indefinida"! = typeof window?: this, function (a, b) { var c = [], d = um.documento, e = c.slice, f = c.concat, g = c.push, h = c.indexOf, i = {}, j = i.toString, k = i .hasOwnProperty, l = {}, m = "1.12.4", n = função (a, b) {retornar novo n.fn.init (a, b)}, o = / ^ [\ s \ uFEFF \ xA0 ] + | [\ s \ uFEFF \ xA0] + $ / g, p = / ^ - ms - /, q = / - ([\ da-z]) / gi, r = funç˜ao (a, b) {return b.toUpperCase ()}; n.fn = n.prototype = {jquery: m, construtor: n, seletor: "", length: 0, toArray: function () {retorno e.call (this)}, obtenha: function (a) {retornar null! = a? 0> a? isto [a + este.length]: este [a]: e.call (this)}, pushStack: function (a) {var b = n.merge (this.constructor (), a); retorno b.prevObject = this, b.context = this.context, b}, cada: function (a) {retornar n.each (this, a)}, map: function (a) {retornar this.pushStack (n.map) , função (b, c) {return a.call (b, c, b)}))}, fatia: function () {return this.pushStack (e.apply (isto, argumentos))}, primeiro: function ( ) {return this.eq (0)}, last: function () {retornar this.eq (-1)}, eq: function (a) {var b = este.length, c = + a + (0> a? b: 0); return this.pushStack (c> = 0 && b> c? [isto [c]]: [])}, end: function () {retorne this.prevObject || this.constructor ()}, pressione: g, classificar: c.sort, splice: c.splice}, n.extend = n.fn.extend = function () {var a, b, c, d, e, f, g = argumentos [0] || {}, h = 1, i = argumentos.length, j =! 1, para ("booleano" == typeof g && (j = g, g = argumentos [h] || {}, h ++), "objeto" = = typeof g || n.isFunction (g) || (g = {}), h === i && (g = isto, h -); i> h; h ++) if (null! = (e = argumentos [h])) para (d em e) a = g [d], c = e [d], g! == c && (j && c && (n.isPlainObject (c) || ​​(b = n.isArray (c)))? (b? (b =! 1, f = a && n.isArray (a)? a: []): f = a && n. isPlainObject (a)? a: {}, g [d] = n.extend (j, f, c)): void 0! == c && (g [d] = c)); return g}, n.extend ({expando: "jQuery" + (m + Math.random ()). substituir (/ \ D / g, ""), isReady:! 0, erro: function (a) {lançar novo erro (a)}, noop: function () {}, isFunction: function (a) {retorno "function" === n.type (a)}, isArray: Array.isArray || function (a) {retorno "array" === n .type (a)}, isWindow: function (a) {return nulo! = a && a == a.window}, isNumeric: function (a) {var b = a && a.toString (); retorno! n.isArray (a) && b-parseFloat (b) +1> = 0}, isEmptyObject: function (a) {var b; para (b em a) retorno! 1; retorno! 0}, isPlainObject: function (a) {var b; if ( ! a || "objeto"! == n.type (a) || a.nodeType || n.isWindow (a)) return! 1; tente {if (a.constructor &&! k.call (a, "construtor ") &&! k.call (a.constructor.prototype," isPrototypeOf ")) return! 1} captura (c) {return! 1} if (! l.ownFirst) para (b em a) return k.call (a, b); para (b em a); return void 0 === b || k.call (a, b)}, tipo: function (a) {retorno null == a? a + "": " objeto "== typeof a ||" function "== tipoof a? i [j.call (a)] ||" objeto ": typeof a}, globalEval: function (b) {b && n.trim (b) && ( a.execScript || function (b) {a.eval.call (a, b)}) (b)}, camelCase: function (a) {return a.replace (p, "ms -"). substitua (q , r)}, nodeName: function (a, b) {return a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, cada: function (a, b) {var c, d = 0; if (s (a)) {para (c = a.length; c> d; d ++) se (b.call (a [d], d, a [d]) ===! 1) quebra} mais para (d em a) if (b.call (a [d], d, a [d]) ===! 1) quebra; retorna a}, trim: function (a) {retorno nulo == a? "" : (a + ""). substitua (o, "")}, makeArray: function (a, b) {var c = b || []; retorna nulo! = a && (s (Objeto (a))? n.merge (c," string "== tipoof a? [a]: a): g.call (c, a)), c}, inArray: function (a, b, c) {var d; if (b) {se (h) retorna h.call (b, a, c); para (d = b.length, c = c? 0> c? Math.max (0, d + c): c: 0; d> c; c ++) if (c em b && b [c] === a) retorne c} return-1}, mescla: function (a, b) {var = comprimento, d = 0, e = a.length; while (c> d) a [e ++] = b [d ++]; if (c! == c) while (void 0! == b [d]) a [e ++] = b [d ++]; retorno a.length = e, a}, grep: function ( a, b, c) {para (var d, e = [], f = 0, g = a.length, h =! c; g> f; f ++) d =! b (a [f], f) , d! == h && e.push (a [f]); return e}, map: function (a, b, c) {var d, e, g = 0, h = []; se (s (a) ) para (d = a.length; d> g; g ++) e = b (a [g], g, c), nulo! = e && h.push (e); else para (g in a) e = b ( a [g], g, c), nulo! = e && h.push (e); retorno f.apply ([], h)}, guid: 1, proxy: função (a, b) {var c, d, f; return "string" == typeof b && (f = a [b], b = a, a = f),n.isFunction (a)? (c = e.call (argumentos, 2), d = function () {return a.apply (b || isso, c.concat (e.call (argumentos)))}, d .guid = a.guid = a.guid || n.guid ++, d): void 0}, agora: function () {return + nova data}, suporte: l}), "function" == typeof Symbol && (n .fn [Symbol.iterator] = c [Symbol.iterator]), n.each ("Número da Função da String Booleana Data Matriz RegExp Objeto Símbolo de Erro" .split (""), function (a, b) {i ["[ objeto "+ b +"] "] = b.toLowerCase ()}); função s (a) {var b = !! a &&" comprimento "em a && a.length, c = n.type (a); retorno" function " === c || n.isWindow (a) ?! 1: "array" === c || 0 === b || "número" == typeof b && b> 0 && b-1 em uma função} var t = (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "chiar" +1 * nova Data, v = a.document, w = 0, x = 0, y = ga (), z = ga (), A = ga (), B = função (a, b) {return a === b &&(l =! 0), 0}, C = 1 << 31, D = {} hasOwnProperty, E = [], F = E. pop, G = E.push, H = E.push, I = E .slice, J = função (a, b) {para (var c = 0, d = a.length; d> c; c ++) se (a [c] === b) retornar c; retorno-1}, K = "marcado | selecionado | async | autofocus | autoplay | controles | defer | desativado | oculto | ismap | loop | múltiplo | aberto | readonly | obrigatório | com escopo", L = "[\\ x20 \\ t \\ r \ \ n \\ f] ", M =" (?: \\\\. | [\\ w-] | [^ \\ x00 - \\ xa0]) + ", N =" \\ ["+ L + "* (" + M + ") (?:" + L + "* ([* ^ $ |! ~]? =)" + L + "* (?: '((?: \\\\. | [^ \ \\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ "| (" + M + ")) |)" + L + " * \\] ", O =" :( "+ M +") (?: \\ ((('((?: \\\\. | [^ \\\\']) *) '| \ " ((?: \\\\. | [^ \\\\\ ")] *) \") | ((?: \\\\. | [^ \\\\ () [\\]] | "+ N +") *) |. *) \\) |) ", P = novo RegExp (L +" + "," g "), Q = novo RegExp (" ^ "+ L +" + | ((?:^ | [^ \\\\]) (?: \\\\.) *) "+ L +" + $ "," g "), R = novo RegExp (" ^ "+ L +" *, "+ L + "*"), S = new RegExp ("^" + L + "* ([> + ~] |" + L + ")" + L + "*"), T = novo RegExp ("=" + L + "* ( [^ \\] '\ "] *?)" + L + "* \\]", "g"), U = novo RegExp (O), V = novo RegExp ("^" + M + "$"), W = {ID: new RegExp ("^ # (" + M + ")"), CLASS: novo RegExp ("^ \\. (" + M + ")"), TAG: new RegExp ("^ (" + M + "| [*])"), ATTR: new RegExp ("^" + N), PSEUDO: novo RegExp ("^" + O), CHILD: new RegExp ("^ :( apenas | primeiro | último | nth | nth-last) - (child | of-type) (?: \\ ("+ L +" * (par | ímpar | (([+ -] |) (\\ d *) n |) "+ L +" * (?: ([+ -] |) "+ L +" * (\\ d +) |)) "+ L +" * \\) |) "," i "), bool: novo RegExp (" ^ (?: "+ K +") $ ","i "), needsContext: new RegExp (" ^ "+ L +" * [> + ~] |: (par | ímpar | eq | gt | lt | nth | primeiro | último) (?: \\ ("+ L +" * ((?: - \\ d)? \\ d *) "+ L +" * \\) |) (? = [^ -] | $) "," i ")}, X = / ^ (? : input | select | textarea | button) $ / i, Y = / ^ h \ d $ / i, Z = / ^ [^ {] + \ {\ s * \ [nativo \ w /, $ = / ^ ( ?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, _ = / [+ ~] /, aa = / '| \\ / g, ba = new RegExp ("\\\\ ([\\ da-f] {1,6}" + L + "? | (" + L + ") |.)", "ig"), ca = função (a , b, c) {var d = "0x" + b-65536; retorno d! == d || c? b: 0> d? String.fromCharCode (d + 65536): String.fromCharCode (d >> 10 | 55296,1023 & d | 56320}}, da = function () {m ()}; try {H.apply (E = I.call (v.childNodes), v.childNodes), E [v.childNodes.length] .nodeType} catch (ea) {H = {aplicar: função E.length? (a, b) {G.apply (a, I. chamada (b))}: function (a, b) {var c = a .length, d = 0; while (a [c ++] = b [d ++]); a.length = c-1}}} função fa (a, b, d, e) {var f, h, j, k , l, o, r,s, w = b && b.ownerDocument, x = b? b.nodeType: 9; if (d = d || [], "string"! = tipo de ||! a || 1! == x && 9! == x && 11 ! == x) return d; if (! e && ((b`ownerDocument || b: v)! == n && m (b), b = b || n, p)) {se (11! == x && (o = $. exec (a))) if (f = o [1]) {se (9 === x) {if (! (j = b.getElementById (f))) retornará d; j.id === f) retorne d.push (j), d} else if (w && (j = w.getElementById (f)) && t (b, j) && j.id === f) retorne d.push (j), d} else {if (o [2]) retorna H.apply (d, b.getElementsByTagName (a)), d; if ((f = o [3]) && c.getElementsByClassName && b.getElementsByClassName) return H .apply (d, b.getElementsByClassName (f)), d} if (c.qsa &&! A [a + ""] && (! q ||! q.test (a))) {se (1! == x ) w = b, s = a; else if ("objeto"! == b.nodeName.toLowerCase ()) {(k = b.getAttribute ("id"))? k = k.replace (aa, "\ \ $ & "): b.setAttribute (" id ", k = u),r = g (a), h = r.length, l = V.test (k)? "#" + k: "[id = '" + k + "']"; enquanto (h -) r [h ] = l + "" + qa (r [h]); s = r.join (","), w = _. teste (a) && oa (b.parentNode) || b} se (s) tentar {return H.apply (d, w.querySelectorAll (s)), d} catch (y) {} finalmente {k === u && b.removeAttribute ("id")}}} retornar i (a.replace (Q, "$ 1 "), b, d, e)} função ga () {var a = []; função b (c, e) {retornar a.push (c +" ")> d.cacheLength && excluir b [a.shift ()] , b [c + ""] = e} return b} função ha (a) {return a [u] =! 0, a} função ia (a) {var b = n.createElement ("div"); return! a (b)} catch (c) {return! 1} finalmente {b.parentNode && b.parentNode.removeChild (b), b = nulo}} function ja (a, b) {var = a.split ( "|"), e = c.length; while (e -) d.attrHandle [c [e]] = b} função ka (a, b) {var = b && a, d = c && 1 === a. nodeType && 1 === b.nodeType && (~ b.sourceIndex || C) - (~ a.sourceIndex || C); if (d) retorna d; if (c) while (c = c.nextSibling) se (c === b) retornar 1; retorna a função? 1: -1} la (a) {função return (b) {var = b.nodeName.toLowerCase (); retorna função "input" === c && b.type === a}} ma (a) {função return (b) {var = b.nodeName.toLowerCase (); return ("input" === c || "button" === c) && b.type === a}} função na (a) {retorno ha (função (b) {retorno b = + b, ha (função (c, d) {var e, f = a ([], c.length, b), g = f. length; while (g -) c [e = f [g]] && (c [e] =! (d [e] = c [e]))})})} função oa (a) {return a && "undefined"! = typeof a.getElementsByTagName && a} c = fa.support = {}, f = fa.isXML = função (a) {var b = a && (a.ownerDocument || a) .documentElement; return b? "HTML "! == b.nodeName:! 1}, m = fa.setDocument = função (a) {var b, e, g = a? proprietário.Documento || a: v; retorno g! == n &&9 === g.nodeType && g.documentElement? (N = g, o = n.documentElement, p =! F (n), (e = n.defaultView) && e.top! == e && (e.addEventListener? E. addEventListener ("unload", da,! 1): e.attachEvent && e.attachEvent ("onunload", da)), c.attributes = ia (function (a) {retorno a.className = "i",! a.getAttribute ("className")}), c.getElementsByTagName = ia (function (a) {retornar a.appendChild (n.createComment ("")) ,! a.getElementsByTagName ("*"). length}), c.getElementsByClassName = Z.test (n.getElementsByClassName), c.getById = ia (função (a) {retorno o.appendChild (a) .id = u,! N.getElementsByName ||! N.getElementsByName (u) .length}) , c.getById? (d.find.ID = função (a, b) {if ("indefinido"! = tipo de b.getElementById && p) {var = b.getElementById (a); retorno c? [c]: [ ]}}, d.filter.ID = function (a) {var b = a.replace (ba, ca);função de retorno (a) {return a.getAttribute ("id") === b}}) :( delete d.find.ID, d.filter.ID = função (a) {var b = a.replace (ba , ca); função return (a) {var c = "undefined"! = tipoof a.getAttributeNode && a.getAttributeNode ("id"); return c && c.value === b}}), d.find.TAG = c. getElementsByTagName? function (a, b) {retorno "undefined"! = tipo de b.getElementsByTagName? b.getElementsByTagName (a): c.qsa? b.querySelectorAll (a): void 0}: function (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a); if ("*" === a) {enquanto (c = f [e ++]) 1 === c.nodeType && d.push ( c); return d} retornar f}, d.find.CLASS = c.getElementsByClassName && function (a, b) {retorno "undefined"! = tipo de b.getElementsByClassName && p? b.getElementsByClassName (a): void 0}, r = [ ], q = [], (c.qsa = Z.test (n.querySelectorAll)) && (ia (função (a) {o.appendChild (a).innerHTML = "<a id='"+u+"'> </a> <selecionar id = '" + u + "- \ r \\' msallowcapture = ''> <opção selecionada = ''> </ option> < / select> ", a.querySelectorAll (" [msallowcapture ^ = ''] "). comprimento && q.push (" [* ^ $] = "+ L +" * (?: '' | \ "\") "), a.querySelectorAll ("[selecionado]"). length || q.push ("\\ [" + L + "* (?: valor |" + K + ")"), a.querySelectorAll ("[id ~ =" + u + "-]"). length || q.push ("~ ="), a.querySelectorAll (": verificada"). length || q.push (": checked"), a.querySelectorAll ("a # "+ u +" + * "). length || q.push (". #. + [+ ~] ")}), ia (função (a) {var b = n.createElement (" input "); .setAttribute ("type", "hidden"), a.appendChild (b).setAttribute ("name", "D"), a.querySelectorAll ("[nome = d]"). length && q.push ("nome" + L + "* [* ^ $ |! ~]? ="), a. querySelectorAll (": enabled"). length || q.push (": enabled", ": disabled"), a.querySelectorAll ("* ,:"), q.push (",. *:")} )), (c.matchesSelector = Z.test (s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia (function (a) {c.disconnectedMatch = s.call (a, "div"), s.call (a, "[s! = '']: x"), r.push ("! =", O)}), q = q.length && new RegExp (q.join ("|")), r = r.length && new RegExp (r.join ("|")), b = Z.teste (o.compareDocumentPosition), t = b || Z.test (o. contém)? function (a, b) {var = 9 == = a.nodeType? a.documentElement: a, d = b && b.parentNode; retorno a === d ||! (! d || 1! = = d.nodeType ||! (c.contains? c.contains (d): a.compareDocumentPosition && 16 & a.compareDocumentPosition (d)))}: function (a, b) {se (b) while (b = b.parentNode) if (b === a) retornar! 0; retornar! 1}, B = b? função (a, b) {if (a === b) retornar l =! 0,0; var d =! a.compareDocumentPosition-! b.compareDocumentPosition; return d? d: (d = (a.ownerDocument || a) === (b.ownerDocument || b)? a.compareDocumentPosition (b): 1,1 & d ||! c.sortDetached && b.compareDocumentPosition (a) === d? a === n || a.ownerDocument === v && t (v, a)? - 1: b === n || b.ownerDocument === v && t (v, b) ? 1: k? J (k, a) -J (k, b): 0: 4 & d? -1: 1)}: funï¿½o (a, b) {se (a === b) retorna l =! 0 , 0; var c, d = 0, e = a.parentNode, f = b.parentNode, g = [a], h = [b]; se (! E ||! F) retorna a === n? -1: b = n = 1? E? -1: f? 1: k? J (k, a) -J (k, b): 0; se (e === f) retornar ka (a , c = a; while (c = c.parentNode) g.unshift (c); c = b; enquanto (c = c.parentNode) h.unshift (c); enquanto (g [d] == = h [d]) d ++; retorno d? ka (g [d], h [d]):g [d] === v? -1: h [d] === v? 1: 0}, n): n}, fa.matches = função (a, b) {retorno fa (a, nulo, null, b)}, fa.matchesSelector = function (a, b) {se ((a.ownerDocument || a)! == n && m (a), b = b.replace (T, "= '$ 1']" ), c.matchesSelector && p &&! A [b + ""] && (! r ||! r.test (b)) && (! q ||! q.test (b))) tente {var d = s.call ( a, b); se (d || c.disconnectedMatch || a.document && 11! == a.document.nodeType) retorne d} catch (e) {} retorne fa (b, n, nulo, [a]). length> 0}, fa.contains = function (a, b) {retorno (a.ownerDocument || a)! == n && m (a), t (a, b)}, fa.attr = função (a, b ) {(a.ownerDocument || a)! == n && m (a); var e = d.attrHandle [b.toLowerCase ()], f = e && D.call (d.attrHandle, b.toLowerCase ())? e (a, b,! p): void 0; return void 0! == f? f: c.attributes ||! p? a.getAttribute (b): (f = a.getAttributeNode (b)) && f.specified f.value: null}, fa.error = function (a) {lançar novo erro ("Erro de sintaxe, expressão não reconhecida:" + a)}, fa.uniqueSort = função (a) {var b, d = [], e = 0, f = 0; (l =! c.detectDuplicates, k =! c.sortStable && a.slice (0), a.sort (B), l) {enquanto (b = a [f ++]) b === a [f] && (e = d.push (f)); while (e -) a.splice (d [e], 1)} retorno k = null, a}, e = fa.getText = função (a) {var b, c = "", d = 0, f = a.nodeType; if (f) {se (1 === f || 9 === f || 11 === f) {if ("string" == tipo de a.textContent) retornar a.textContent, para (a = a.firstChild; a; a = a.nextSibling) c + = e (a)} else if (3 === f || 4 === f) retornar um .nodeValue} else while (b = a [d ++]) c + = e (b); retorno c}, d = fa.selectors = {cacheLength: 50, createPseudo: ha, correspondência: W, attrHandle: {}, localizar: {}, relative: {">": {dir: "parentNode", primeiro:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", primeiro:! 0} , "~": {dir: "previousSibling "}}, preFilter: {ATTR: função (a) {return a [1] = a [1] .replace (ba, ca), a [3] = (a [3] || a [4] | | a [5] || ""). substitua (ba, ca), "~ =" === a [2] && (a [3] = "" + a [3] + ""), a. slice (0,4)}, CHILD: function (a) {retornar a [1] = a [1] .toLowerCase (), "nth" === a [1] .slice (0,3)? [3] || fa.error (a [0]), a [4] = + (a [4]? A [5] + (a [6] || 1): 2 * ("par" == = a [3] || "ímpar" === a [3])), a [5] = + (a [7] + a [8] || "ímpar" === a [3])) : a [3] && fa.error (a [0]), a}, PSEUDO: function (a) {var b, c =! a [6] && a [2]; retorno W.CHILD.test (a [0 ])? null: (a [3]? a [2] = a [4] || a [5] || "": c && U.test (c) && (b = g (c,! 0)) && (b = c.indexOf (")", c.length-b) -c.length) && (a [0] = a [0] .slice (0, b), a [2] = c.slice ( 0, b)), a.slice (0,3))}}, filtro: {TAG: função (a) {var b = a.replace (ba, ca). Para menorCase (); retorno "*"=== a? function () {return! 0}: function (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, CLASS: function (a) {var b = y [a + " "]; return b || (b = new RegExp (" (^ | "+ L +") "+ a +" ("+ L +" | $) ")) && y (a, função (a) {retorno b.teste ("string" == typeof a.className && a.className || "undefined"! = tipo de a.getAttribute && a.getAttribute ("class") || "")})}, ATTR: function (a, b, c) { função de retorno (d) {var e = fa.attr (d, a); retorno nulo == e? "! =" === b: b? (e + = "", "=" === b? e === c: "! =" === b? e! == c: "^ =" === b? c && 0 === e.indexOf (c): "* =" === b? c && e .indexOf (c)> - 1: "$ =" === b? c && e.slice (-c.length) === c: "~ =" === b? ("" + e.replace (P , "") + "") .indexOf (c)> - 1: "| ="=== b? e === c || e.slice (0, c.length + 1) === c + "-" :! 1) :! 0}}, CHILD: função (a, b, c , d, e) {var f = "nth"! == a.slice (0,3), g = "last"! == a.slice (-4), h = "do tipo" === b; return 1 === d && 0 === e? function (a) {retorno !! a.parentNode}: function (b, c, i) {var j, k, l, m, n, o, p = f! == g? "nextSibling": "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase (), s =! i &&! h, t =! 1; se (q) {se (f ) {while (p) {m = b; enquanto (m = m [p]) se (h? m.nodeName.toLowerCase () === r: 1 === m.nodeType) retorna! 1; o = p = "only" === a &&! o && "nextSibling"} return! 0} if (o = [g? q.firstChild: q.lastChild], g && s) {m = q, l = m [u] || (m [u] = {}), k = l [m.uniqueID] || (l [m.uniqueID] = {}), j = k [a] || [], n = j [0] = == w && j [1], t = n && j [2], m = n && q.childNodes [n]; enquanto (m = ++ n && m && m [p] || (t = n = 0) || o.pop ()) if (1 === m.nodeType &&++ t && m === b) {k [a] = [w, n, t]; quebra}} else if (s && (m = b, l = m [u] || (m [u] = {} ), k = l [m.uniqueID] || (l [m.uniqueID] = {}), j = k [a] || [], n = j [0] === w && j [1], t = n), t ===! 1) while (m = ++ n && m && m [p] || (t = n = 0) || o.pop ()) if ((h? m.nodeName.toLowerCase () === r: 1 === m.nodeType) && ++ t && (s && (l = m [u] || (m [u] = {}), k = l [m.uniqueID] || (l [m.uniqueID] = {}), k [a] = [w, t]), m === b)) quebra; retorno t- = e, t === d || t% d === 0 && t / d> = 0}}}, PSEUDO: function (a, b) {var c, e = d.pseudos [a] || d.setFilters [a.toLowerCase ()] || fa.error ("sem suporte pseudo: "+ a); return e [u]? e (b): e.length> 1? (c = [a, a," ", b], d.setFilters.hasOwnProperty (a.toLowerCase ()) ? ha (função (a, c) {var d, f = e (a, b), g = f.length, enquanto (g -) d = J (a, f [g]), a [d] =! (c [d] = f [g])}): function (a) {return e (a, 0, c)}): e}}, pseudos: {não: ha (função (a) {var b = [], c = [], d = h (a.replace (Q, "$ 1"));retorno d [u] ha (função (a, b, c, e) {var f, g = d (a, nulo, e, []), h = comprimento a, enquanto (h -) (f = g [h]) && (a [h] =! (b [h] = f))}): function (a, e, f) {retorno b [0] = a, d (b, nulo, f , c), b [0] = nulo,! c.pop ()}}), tem: ha (função (a) {função de retorno (b) {retorno de f (a, b) .comprimento> 0}}) , contém: ha (função (a) {return a = a.replace (ba, ca), função (b) {return (b.textContent || b.innerText || e (b)). indexOf (a)> -1}}), lang: ha (função (a) {return V.test (a || "") || fa.error ("idioma não suportado:" + a), a = a.replace (ba, ca ) .toLowerCase (), function (b) {var c; do if (c = p? b.lang: b.getAttribute ("xml: lang") || b.getAttribute ("lang")) return c = c .toLowerCase (), c === a || 0 === c.indexOf (a + "-"); while ((b = b.parentNode) && 1 === b.nodeType); retorno! 1}}) , target: function (b) {var = a.location && a.location.hash; return c && c.slice (1) === b.id}, raiz: function (a) {retorno a === o},focus: function (a) {return a === n.activeElement && (! n.hasFocus || n.hasFocus ()) && !! (a.type || a.href || ~ a.tabIndex)}, habilitado : function (a) {return a.disabled ===! 1}, desabilitado: function (a) {return a.disabled ===! 0}, verificado: function (a) {var b = a.nodeName.toLowerCase (); return "input" === b && !! a.checked || "option" === b && !! a.selected}, selecionado: function (a) {return a.parentNode && a.parentNode.selectedIndex, a. selecionado ===! 0}, vazio: function (a) {for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType <6) retornar! 1; return! 0}, pai: function (a) {return! d.pseudos.empty (a)}, cabeçalho: function (a) {retorno Y.test (a.nodeName)}, entrada: function (a) {retorno X.test (a.nodeName )}, botão: function (a) {var b = a.nodeName.toLowerCase (); retorna "input" === b && "button" === a.type || "button" === b}, texto : function (a) {var b; retorno "input "=== a.nodeName.toLowerCase () &&" text "=== a.type && (null == (b = a.getAttribute (" type ")) ||" texto "=== b.toLowerCase ( )), primeiro: na (function () {return [0]}), last: na (função (a, b) {retorno [b-1]}), eq: na (função (a, b, c ) {return [0> c? c + b: c]}), mesmo: na (funo (a, b) {para (var c = 0; b> c; c + = 2) a.push (c); return a}), odd: na (função (a, b) {para (var c = 1; b> c; c + = 2) a.push (c); retorno a}), lt: na (função (a , b, c) {para (var d = 0> c? c + b: c; - d> = 0;) a.push (d); retorno a}), gt: na (funo (a, b c) {para (var d = 0> c + c + b: c; ++ d <b;) a.push (d); retorne a})}}, d.pseudos.nth = d.pseudos. eq; para (b em {radio:! 0, checkbox:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) d.pseudos [b] = la (b); para (b in { submit:! 0, reset:! 0}) d.pseudos [b] = ma (b); função pa () {} pa.prototype = d.filters = d.pseudos, d.setFilters = novo pa, g = fa.tokenize = função (a, b) {var c, e, f, g, h, i, j, k = z [a + ""];se (k) retornar b? 0: k.slice (0); h = a, i = [], j = d.preFilter; enquanto (h) {c &&! (e = R.exec (h)) || (e && (h = h.slice (e [0] .comprimento) || h), i.push (f = [])), c =! 1, (e = S.exec (h)) && (c = e.shift (), f.push ({valor: c, tipo: e [0] .replace (Q, "")}), h = h.slice (c.length)); para (g em d .filter)! (e = W [g] .exec (h)) || j [g] &&! (e = j [g] (e)) || (c = e.shift (), f.push ({valor: c, tipo: g, combinações: e}), h = h.slice (c.length)); if (! c) break} retorno b? h.length: h? fa.error (a) : z (a, i) .segmento (0)}; função qa (a) {para (var b = 0, c = a.length, d = ""; c> b; b ++) d + = a [b] .value; return d} função ra (a, b, c) {var d = b.dir, e = c && "parentNode" === d, f = x ++; retorno b.first? função (b, c, f ) {while (b = b [d]) if (1 === b.nodeType || e) retorna a (b, c, f)}: função (b, c, g) {var h, i, j , k = [w, f]; if (g) {enquanto (b = b [d]) se ((1 === b.nodeType || e) && a (b, c, g)) retorno! 0} else while (b = b [d]) if (1 === b.nodeType || e) {se (j = b [u] || (b [u] = {}),i = j [b.uniqueID] || (j [b.uniqueID] = {}), (h = i [d]) && h [0] === w && h [1] === f) retorno k [2 ] = h [2]; if (i [d] = k, k [2] = a (b, c, g)) retorno! 0}}} função sa (a) {retorno a.length> 1? function (b, c, d) {var e = a.length; while (e -) se (! a [e] (b, c, d)) retorna! 1; retorna! 0}: a [0]} função ta (a, b, c) {para (var d = 0, e = b.length; e> d; d ++) fa (a, b [d], c); retorno c} função ua (a, b c, d, e) {para (var f, g = [], h = 0, i = comprimento, j = nulo! = b; i> h; h ++) (f = a [h]) && (c &&! c (f, d, e) || (g.push (f), j && b.push (h))); retorno g} função va (a, b, c, d, e, f) {retorno d &&! d [u] && (d = va (d)), e & !, e [u] && (e = va (e, f)), ha (função (f, g, h, i) {var j, k, l, m = [], n = [], o = g.length, p = f || ta (b || "*", h.nodeType? [h]: h, []), q = a |||||||||||||||||||||||||||||||||||||||||||| (q, r, h, i), d) {j = ua (r, n), d (j, [], h, i), k = j.length; enquanto (k -) (l = j [k]) && (r [n [k]] =!(q [n [k]] = l))} se (f) {se (e || a) {se (e) {j = [], k = r.length; enquanto (k -) (l = r [k]) &&j.push (q [k] = l); e (nulo, r = [], j, i)} k = r.length; enquanto (k -) (l = r [k ]) && (j = e? J (f, l): m [k])> - 1 && (f [j] =! (g [j] = l))}} mais r = ua (r === g.splice (o, r.length): r), e? e (null, g, r, i): H.aplicação (g, r)})} função wa (a) {para (var b , c, e, f = a.length, g = d.relative [a [0] .type], h = g || d.relative [""], i = g? 1: 0, k = ra ( função (a) {retorno a === b}, h,! 0), l = ra (função (a) {retorno J (b, a)> - 1}, h,! 0), m = [função (a, c, d) {var e =! g && (d || c! == j) || ((b = c) .nodeTipo? k (a, c, d): l (a, c, d )); return b = null, e}]; f> i; i ++) if (c = d.relativo [a [i] .type]) m = [ra (sa (m), c)]; if (c = d.filter [a [i] .tipo] .apply (null, a [i] .matches), c [u]) {para (e = ++ i; f> e; e ++) if ( d.relativo [a [e] .tipo]) quebra; retorno va (i> 1 && sa (m), i> 1 && qa (a.slice (0, i-1) .concat ({valor: "" === a [i-2] .type? "*": ""})). replace (Q, "$ 1"), c, e> i && wa (a.slice (i, e)), f> e & wa (a = a.slice (e)), f> e & qa (a)) } m.push (c)} retornar sa (m)} função xa (a, b) {var = comprimento_c> 0, e = comprimento_alta> 0, f = função (f, g, h, i , k) {var l, o, q, r = 0, s = "0", t = f && [], u = [], v = j, x = f || e && d.find.TAG ("*" , k), y = w + = null == v? 1: Math.random () || .1, z = x.length, para (k && (j = g == n n || g || k); s! == z && null! = (l = x [s]); s ++) {se (e & l) {o = 0, g || l.ownerDocument === n || (m (l), h =! p ); while (q = a [o ++]) se (q (l, g || n, h)) {i.push (l); quebra} k && (w = y)} c && ((l =! q && l) && r -, f && t.push (l)}} se (r + = s, c && s! == r) {o = 0; enquanto (q = b [o ++]) q (t, u, g, h); (f) {se (r> 0) enquanto (s -) t [s] || u [s] || (u [s] = F.call (i)); u = ua (u)} H .apply (i, u), k &&! f & u.length> 0 && r + b.length> 1 && fa.uniqueSort (i)} retorno k && (w = y,j = v), t}; retorno c? ha (f): f} retorno h = fa.compile = função (a, b) {var c, d = [], e = [], f = A [a + ""]; if (! f) {b || (b = g (a)), c = b.length; enquanto (c -) f = wa (b [c]), f [u] d (f): e.push (f); f = A (a, xa (e, d)), f.selector = a} retorno f}, i = fa.select = função (a, b, e , f) {var i, j, k, l, m, n = "função" == tipoof a && a, o =! f && g (a = n.seletor || a); se (e = e || [], 1 === o.length) {if (j = o [0] = o [0] .segmento (0), j.length> 2 && "ID" === (k = j [0]) digite && c. getById && 9 === b.nodeType && p && d.relative [j [1] .type]) {se (b = (d.find.ID (k.matches [0] .replace (ba, ca), b) || [] ) [0],! B) return e; n && (b = b.parentNode), a = a.slice (j.shift (). Value.length)} i = W.needsContext.test (a)? 0: j.length; while (i -) {if (k = j [i], d.relativo [l = k.type]) quebra; if ((m = d.find [l]) && (f = m (k.matches [0] .replace (ba, ca), _. test (j [0] .type) && oa (b.parentNode) || b))) {se (j.splice (i, 1),a = f.length && qa (j), a) retornar H.apply (e, f), e; break}}} return (n || h (a, o)) (f, b, p, e, ! b || _test (a) && oa (b.parentNode) || b), e}, c.sortStable = u.split (""). sort (B) .join ("") === u , c.detectDuplicates = !! l, m (), c.sortDetached = ia (função (a) {retorno 1 & a.compareDocumentPosition (n.createElement ("div"))}), ia (function (a) {return a .innerHTML = "<a href='#'> </a>", "#" === a.firstChild.getAttribute ("href")}) || ja ("tipo | href | altura | largura", função (a, b, c) {retorno c? void 0: a.getAttribute (b, "tipo" === b.toLowerCase ()? 1: 2)}), c.attributos && ia (function (a) {return a.innerHTML = "<input />", a.firstChild.setAttribute ("valor", ""), "" === a.firstChild.getAttribute ("valor")}) || ja ("valor", função (a, b,c) {return c || "input"! == a.nodeName.toLowerCase ()? void 0: a.defaultValue}), ia (function (a) {retorno null == a.getAttribute ("disabled")} ) || ja (K, função (a, b, c) {var d; retorno c? void 0: a [b] ===! 0? b.toLowerCase () :( d = a.getAttributeNode (b) ) && d.specified? d.value: null}), fa} (a); n.find = t, n.expr = t.seletores, n.expr [":"] = n.expr.pseudos, n. uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains; var u = função (a, b, c) {var d = [ ], e = void 0! == c; while ((a = a [b]) && 9! == a.nodeType) if (1 === a.nodeType) {if (e & n (a) .is (c )) break; d.push (a)} return d}, v = function (a, b) {para (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a! == b && c.push (a); return c}, w = n.expr.match.needsContext, x = / ^ <([\ w -] +) \ s * \ /?> (?: <\ / \ 1> |) $ /, y = / ^. [^: # \ [\.,] * $ /; function z (a, b, c) {if (n.isFunction (b)) return n.grep (a,function (a, d) {retorno !! b.call (a, d, a)! == c}); if (b.nodeType) return n.grep (a, função (a) {return a === b! == c}); if ("string" == typeof b) {if (y.test (b)) retorna n.filter (b, a, c); b = n.filter (b, a) } return n.grep (a, function (a) {retornar n.inArray (a, b)> - 1! == c})} n.filter = função (a, b, c) {var d = b [ 0]; return c && (a = ": not (" + a + ")"), 1 === b.length && 1 === d.nodeType? N.find.matchesSelector (d, a)? [D]: [ ]: n.find.matches (a, n.grep (b, função (a) {return 1 === a.nodeType}))}, n.fn.extend ({encontrar: function (a) {var , c = [], d = isto, e = d.length; if ("string"! = typeof a) retorna this.pushStack (n (a) .filter (function () {para (b = 0; e> b; b ++) if (n.contains (d [b], this)) return! 0})); para (b = 0; e> b; b ++) n.find (a, d [b], c) ; return c = this.pushStack (e> 1? n.unique (c): c), c.selector = este.selector? este.selector + "" + a: a, c}, filtro: funo (a) { return this.pushStack (z (istoa || [] ,! 1))}, não: function (a) {return this.pushStack (z (isto, a || [] ,! 0))}, é: function (a) {return !! z (isso, "string" == tipo de um && w.test (a)? n (a): a || [] ,! 1). comprimento}}; var A, B = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, C = n.fn.init = função (a, b, c) {var, f; if (! a) return this; if (c = c || A, "string" == tipoof a) {if (e = "<" === a.charAt (0) && ">" == = a.charAt (a.length-1) && a.length> = 3? [null, a, null]: B.exec (a),! e || e e [1] && b) return! b || b .jquery? (b || c) .encontrar (a): this.constructor (b) .find (a); if (e [1]) {if (b = b instância de n? b [0]: b, n.merge (this, n.parseHTML (e [1], b && b.nodeType? b.ownerDocument || b: d,! 0)), x.test (e [1]) && n.isPlainObject (b)) para (e em b) n.isFunção (isto [e])? isto [e] (b [e]): this.attr (e, b [e]); devolva isto} se (f = d.getElementById (e [2]), f && f.parentNode) {if (f.id! == e [2]) return A.find (a);length = 1, this [0] = f} return this.context = d, this.selector = a, isso} return a.nodeType? (this.context = this [0] = a, this.length = 1, isto ): n.isFunction (a)? "undefined"! = tipo de c.ready? c.ready (a): a (n) :( void 0! == a.selector && (this.selector = a.selector, este .context = a.context), n.makeArray (a, this))}; C.prototype = n.fn, A = n (d); var D = / ^ (?: pais | prev (?: Até | Todos)) /, E = {filhos:! 0, conteudo:! 0, proximo:! 0, prev:! 0}; n.fn.extend ({tem: funcao (a) {var b, c = n ( a, this), d = c.length, retornar this.filter (function () {para (b = 0; d> b; b ++) se (n.contains (isso, c [b])) return! 0} )}, mais próximo: function (a, b) {para (var c, d = 0, e = este.length, f = [], g = w.test (a) || "string"! = typeof a? n (a, b || this.context): 0; e> d; d ++) para (c = este [d]; c && c! == b; c = c.parentNode) if (c.nodeType <11 && (g ? g.index (c)> - 1: 1 === c.nodeType && n.find.matchesSelector (c, a))) {f.push (c); break} retorna isso.pushStack (f.length> 1? n.uniqueSort (f): f)}, índice: function (a) {return a? "string" == tipoof a? n.inArray (isto [0], n (a) ): n.inArray (a.jquery? a [0]: a, this): isto [0] && this [0] .parentNode? this.first (). prevAll (). length: -1}, adicionar: função (a, b) {return this.pushStack (n.uniqueSort (n.merge (this.get (), n (a, b))))}, addBack: function (a) {retornar this.add (nulo = = a? this.prevObject: this.prevObject.filter (a))}}); função F (a, b) {fazer a = a [b]; while (a && 1! == a.nodeType); retornar a} n.each ({parent: function (a) {var b = a.parentNode; retorno b && 11! == b.nodeType? b: null}, pais: function (a) {retorno u (a, "parentNode")} , parentsUntil: function (a, b, c) {return u (a, "parentNode", c)}, next: function (a) {retorno F (a, "nextSibling")}, prev: function (a) { return F (a, "previousSibling")}, nextAll: function (a) {retorno u (a, "nextSibling")}, prevAll:function (a) {return u (a, "previousSibling")}, nextUntil: function (a, b, c) {retorno u (a, "nextSibling", c)}, prevUntil: function (a, b, c) {return u (a, "previousSibling", c)}, irmãos: function (a) {return v ((a.parentNode || {}). firstChild, a)}, filhos: function (a) {return v ( a.firstChild)}, contents: function (a) {retornar n.nodeName (a, "iframe")? a.contentDocument || a.contentWindow.document: n.merge ([], a.childNodes)}}, function (a, b) {n.fn [a] = função (c, d) {var e = n.map (isto, b, c); retorno "Até"! == a.slice (-5) && (d = c), d && "string" == tipo de d && (e = n.filter (d, e)), this.length> 1 && (E [a] || (e = n.uniqueSort (e)), D.test (a) && (e = e.reverse ())), this.pushStack (e)}}); var G = / \ S + / g; função H (a) {var b = {}; n.each (a.match (G) || [], função (a, c) {b [c] =! 0}), b} n.Callbacks = function (a) {a = "string"== typeof a? H (a): n.extend ({}, a); var b, c, d, e, f = [], g = [], h = -1, i = função () { para (e = a.once, d = b =! 0; g.length; h = -1) {c = g.shift (); enquanto (++ h <f.length) f [h] .apply ( c [0], c [1]) ===! 1 && a.stopOnFalse && (h = f.length, c =! 1)} a.memória || (c =! 1), b =! 1, e && (f = c? []: "")}, j = {adicionar: function () {retornar f && (c &&! b && (h = f.length-1, g.push (c)), funo d ​​(b) {n .each (b, function (b, c) {n.isFunction (c)? a.unique && j.has (c) || ​​f.push (c): c && c.length && "string"! == n.type (c ) && d (c)})} (argumentos), c &&! b && i ()), isto}, remove: function () {return n.each (argumentos, função (a, b) {var c; while ((c = n.inArray (b, f, c))> - 1) f.splice (c, 1), h> = c && h -}), isto}, tem: function (a) {return a? n.inArray ( a, f)> - 1: f.length> 0}, vazio: function () {return f && (f = []), isto}, desabilitado: function () {return e = g = [],f = c = "", this}, desabilitado: function () {return! f}, lock: function () {retorno e =! 0, c || j.disable (), isto}, bloqueado: function () {return !! e}, fireWith: function (a, c) {return e || (c = c || [], c = [a, c.slice? c.slice (): c], g.push (c), b || i ()), this}, fogo: function () {return j.fireWith (isto, argumentos), isto}, disparado: function () {return !! d}}; return j} , n.extend ({Deferred: function (a) {var b = [["resolver", "feito", n.Callbacks ("once memory"), "resolvido"], ["reject", "fail", n.Callbacks ("once memory"), "rejeitado"], ["notify", "progress", n.Callbacks ("memory")]], c = "pendente", d = {state: function () { return c}, sempre: function () {return e.done (arguments) .fail (arguments), this}, then: function () {var a = argumentos; return n.Deferred (função (c) {n.each (b, função (b, f) {var g = n.isFunção (a [b]) &&a [b]; e [f [1]] (function () {var a = g && g.apply (isto, argumentos); a && n.isFunction (a.promise)? a.promise (). progress (c.notify) .done (c.resolve) .fail (c.reject): c [f [0] + "com"] (isto === d? c.promise (): isto, g? [a]: argumentos)} )}), a = null}). promise ()}, promessa: function (a) {return null! = a? n.extend (a, d): d}}, e = {}; return d.pipe = d.then, n.each (b, função (a, f) {var g = f [2], h = f [3]; d [f [1]] = g.add, h && g.add (função () {c = h}, b [1 ^ a] [2] .disable, b [2] [2] .lock), e [f [0]] = function () {retorno e [f [0] + "Com"] (isto === e? D: this, argumentos), isto}, e [f [0] + "Com"] = g.fireWith}), d.promise (e), a && a.call (e, e), e}, quando: function (a) {var b = 0, c = e.call (argumentos), d = c.length, f = 1! == d || a && n.isFunction (a .promise)? d: 0, g = 1 === f? a: n.Deferred (), h = função (a, b, c) {função de retorno (d) {b [a] = this, c [ a] = arguments.length> 1? e.call (argumentos): d, c === i? g.notifyWith (b, c):--f || g.resolveWith (b, c)}}, i, j, k; if (d> 1) para (i = new Matriz (d), j = novo Matriz (d), k = novo Matriz (d); d> b; b ++) c [b] && n.isFunção (c [b] .promise)? c [b] .promise () .progresso (h (b, j, i)). (b, k, c)) .fault (g.reject): - f; return f || g.resolveWith (k, c), g.promise ()}}); var I; n.fn.ready = function (a) {return n.ready.promise (). done (a), this}, n.extend ({isReady:! 1, prontoWait: 1, holdReady: function (a) {a? n.readyWait ++: n.ready (! 0)}, pronto: function (a) {(a ===! 0? - n.readyWait: n.isReady) || (n.isReady =! 0, a! ==! 0 && --n.readyWait> 0 || (I.resolveWith (d, [n]), n.fn.triggerHandler && (n (d) .triggerHandler ("pronto"), n (d) .off ("pronto") )))}}); função J () {d.addEventListener? (d.removeEventListener ("DOMContentLoaded", K), a.removeEventListener ("carregar", K)) :( d.detachEvent ("onreadystatechange", K ), a.detachEvent ("onload",K))} função K () {(d.addEventListener || "load" === a.event.type || "completo" === d.readyState) && (J (), n.ready ()) } n.ready.promise = function (b) {se (! I) if (I = n.Deferred (), "complete" === d.readyState || "carregando"! == d.readyState &&! d. documentElement.doScroll) a.setTimeout (n.ready); senão if (d.addEventListener) d.addEventListener ("DOMContentLoaded", K), a.addEventListener ("carregar", K); else {d.attachEvent ("onreadystatechange ", K), a.attachEvent (" onload ", K); var c =! 1; tente {c = null == a.frameElement && d.documentElement} catch (e) {} c && c.doScroll &&! Function f () { if (! n.isReady) {try {c.doScroll ("left")} catch (b) {retornar a.setTimeout (f, 50)} J (), n.ready ()}} ()} retornar I .promise (b)}, n.ready.promise (); var L; para (L em n (l)) quebra; l.ownFirst = "0" === L, l.inlineBlockNeedsLayout =! 1, n (função () {var a, b, c, e; c = d.getElementsByTagName ("corpo") [0], c && c.style && (b = d.createElement ("div"), e = d.createElement ("div"), e.style.cssText = "posição: absoluto; limite: 0; largura: 0; altura: 0; topo: 0; esquerdo: -9999px", c.appendChild (e). appendChild (b), "indefinido"! = tipo de b.style.zoom && (b.style.cssText = "display: inline; margem: 0; borda: 0; preenchimento: 1px; largura: 1px; zoom: 1", l .inlineBlockNeedsLayout = a = 3 === b.offsetWidth, a && (c.style.zoom = 1)), c.removeChild (e))}), function () {var a = d.createElement ("div") ; l.deleteExpando =! 0; tente {excluir a.test} catch (b) {l.deleteExpando =! 1} a = nulo} (); var M = função (a) {var b = n.noData [( a.nodeName + "") .toLowerCase ()], c = + a.nodeType || 1; return 1! == c && 9! == c?! 1:! b || b! ==! 0 && a.getAttribute (" classid ") === b}, N = / ^ (?: \ {[\ w \ W] * \} | \ [[w \ W] * \]) $ /, O = / ([AZ]) / g; função P (a, b, c) {se (void 0 === c && 1 === a.nodeType) {var d = "dados -" + b.replace (O, "- $ 1"). toLowerCase ( ); if (c = a.getAttribute (d), "string" == typeof c) {try {c = "verdadeiro" === c?! 0: "falso" === c?! 1: "nulo "=== c? null: + c +" "=== c? + c: N.test (c)? n.parseJSON (c): c} captura (e) {} n.data (a, b, c)} mais c = void 0;
} return c} function Q (a) {var b; para (b em a) if (("dados"! == b ||! n.isEmptyObject (a [b])) && "toJSON"! == b ) return! 1; return! 0} função R (a, b, d, e) {se (M (a)) {var f, g, h = n.expando, i = a.nodeType, j = i? n.cache: a, k = i? a [h]: a [h] && h; if (k && j [k] && (e || j [k] .data) || void 0! == d || " string "! = typeof b) return k || (k = i? a [h] = c.pop () || n.guid ++: h), j [k] || (j [k] = i? { }: {toJSON: n.noop}), "objeto"! = typeof b && "function"! = tipoof b || (e? j [k] = n.extend (j [k], b): j [k ] .data = n.extend (j [k] .data, b)), g = j [k], e || (g.data || (g.data = {}), g = g.data) , void 0! == d && (g [n.camelCase (b)] = d), "string" == typeof b? (f = g [b], null == f && (f = g [n.camelCase ( b)])): f = g, f}} função S (a, b, c) {se (M (a)) {var d, e, f = a.nodeTipo, g = fn.cache: a, h = f? a [n.expando]: n.expando; if (g [h]) {se (b && (d = c? g [h]: g [h] .data)) {n.isArray (b)? b = b.concat (n.map (b, n.camelCase)): b em d? b = [b]: (b = n.camelCase (b), b = b em d? [b]: b.split ("")), e = b.length; while (e -) delete d [b [e]]; se (c?! Q (d):! n.isEmptyObject (d)) return} (c || (delete g [h] .data, Q (g [h]))) && (f? n.cleanData ([a], 0): l.deleteExpando || g! = g.window? delete g [h]: g [h] = void 0)}}} n.extend ({cache: {}, noData: {"applet":! 0, "incorporar":! 0, "objeto": "clsid: D27CDB6E-AE6D-11cf-96B8-444553540000 "}, hasData: function (a) {retornar a = a.nodeType? n.cache [a [n.expando]]: a [n.expando], !! a &&! Q (a)}, data: function ( a, b, c) {retorne R (a, b, c)}, removaData: function (a, b) {retorne S (a, b)}, _ dados: function (a, b, c) {retorne R ( a, b, c,! 0)}, _ removeData: function (a, b) {retorna S (a, b,! 0)}}), n.fn.extend ({dados: function (a, b) { var c, d, e, f = isto [0], g = f && f.atributos; se (vazio 0 === a) {if (this.length && (e = n.data (f), 1 === f .nodeType &&! n._data (f,"parsedAttrs"))) {c = g.length; enquanto (c -) g [c] && (d = g [c] .nome, 0 === d.indexOf ("dados -") && (d = n.camelCase (d.slice (5)), P (f, d, e [d]))); n._data (f, "parsedAttrs",! 0)} return e} retornar "objeto" == typeof a? this.each (function () {n.data (isto, um)}): arguments.length> 1? this.each (function () {n.data (isto, a, b)}): f ? P (f, a, n.data (f, a)): void 0}, removeData: function (a) {retornar this.each (function () {n.removeData (isto, a)})}}) , n.extend ({fila: function (a, b, c) {var d; retorna a? (b = (b || "fx") + "fila", d = n._data (a, b), c && (! d || n.isArray (c)? d = n._data (a, b, n.makeArray (c)): d.push (c)), d || []): void 0}, dequeue: function (a, b) {b = b || "fx"; var c = n.queue (a, b), d = c.length, e = c.shift (), f = n._queueHooks ( a, b), g = função () {n.dequeue (a, b)}; "inprogress" === e && (e = c.shift (), d -), e && ("fx" === b && c.unshift ("inprogress"), delete f.stop, e.call (a, g, f)),! d && f && f.empty.fire ()}, _ queueHooks: function (a, b) {var c = b + " queueHooks "; return n._data (a, c) || ​​n._data (a, c, {vazio: n.Callbacks (" once memory "). add (function () {n._removeData (a, b +" fila "), n._removeData (a, c)})})}}), n.fn.extend ({fila: function (a, b) {var = 2; return" string "! = tipo de a && (b = a, a = "fx", c-), arguments.length <c? n.queue (isto [0], a): void 0 === b? isto: this.each (function () {var c = n.queue (isso, a, b); n._queueHooks (isso, a), "fx" === a && "inprogress"! == c [0] && n.dequeue (this, a)})} , dequeue: function (a) {retornar this.each (function () {n.dequeue (this, a)})}, clearQueue: function (a) {retornar this.queue (a || "fx", [] )}, promessa: function (a, b) {var c, d = 1, e = n.Deferido (), f = isto, g = este.length,h = function () {- d || e.resolveWith (f, [f])}; "string"! = tipo de a && (b = a, a = void 0), a = a || "fx"; while (g -) c = n._data (f [g], a + "filaHooks"), c && c.empty && (d ++, c.empty.add (h)); retorno h (), e.promise (b) }}), function () {var a; l.shrinkWrapBlocks = function () {if (null! = a) retorna a; a =! 1; var b, c, e; return c = d.getElementsByTagName ("corpo ") [0], c && c.style? (B = d.createElement (" div "), e = d.createElement (" div "), e.style.cssText =" posição: absoluto; limite: 0; largura: 0; height: 0; top: 0; left: -9999px ", c.appendChild (e) .appendChild (b)," indefinido "! = Tipo de b.style.zoom && (b.style.cssText =" - webkit- box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; display: bloco; margem: 0; borda: 0; preenchimento: 1px; largura: 1px; zoom: 1 ", b.appendChild (d.createElement (" div ")).style.width = "5px", a = 3! == b.offsetWidth), c.removeChild (e), a): void 0}} (); var T = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. source, U = novo RegExp ("^ (?: ([+ -]) = |) (" + T + " ) ([az%] *) $ "," i "), V = [" Superior "," Direita "," Inferior "," Esquerda "], W = função (a, b) {return a = b | | a, "nenhum" === n.css (a, "exibição") ||! n.contains (a.ownerDocument, a)}; função X (a, b, c, d) {var e f = 1, g = 20, h = d? Função () {retornar d.cur ()}: function () {retornar n.css (a, b, "")}, i = h (), j = c & c [3] || (n.cssNúmero [b]? "": "Px"), k = (n.cssNúmero [b] || "px"! == j && + i) && U.exec (n.css ( a, b)); se (k & k [3]! == j) {j = j || k [3], c = c || [], k = + i || 1; do f = f || ".5", k / = f, n.style (a, b, k + j); enquanto (f! == (f = h () / i) && 1! == f && - g)} retorno c && (k = + k || + i || 0, e = c [1]? k + (c [1] +1) * c [2]: + c [2],d && (d.unit = j, d.start = k, d.end = e)), e} var Y = função (a, b, c, d, e, f, g) {var h = 0, i = a.length, j = null == c; if ("objeto" === n.type (c)) {e =! 0; para (h em c) Y (a, b, h, c [h ], 0, f, g)} else if (void 0! == d && (e =! 0, n.isFuncao (d) || (g =! 0), j && (g? (B.call (a) , d), b = null): (j = b, b = função (a, b, c) {retorno j.call (n (a), c)})), b)) para (; i> h ; h ++) b (a [h], c, g d: d.call (a [h], h, b (a [h], c))); retorno e? a: j? b.call ( a): i? b (a [0], c): f}, Z = / ^ (?: caixa de verificação | rádio) $ / i, $ = / <([\ w: -] +) /, _ = / ^ $ | \ / (?: java | ecma) script / i, aa = / ^ \ s + /, ba = "abbr | artigo | lado | áudio | bdi | tela | dados | datalista | detalhes | diálogo | figcaption | figura | rodapé | cabeçalho | hgroup | principal | marca | medidor | nav | saída | imagem | progresso | seção | resumo | modelo | hora | vídeo "; função ca (a) {var b = ba.split (" | ") , c = a.createDocumentFragment (); if (c.createElement) enquanto (b.length) c.createElement (b.pop ()); retorne c}! function () {var a = d.createElement ("div"), b = d.createDocumentFragment (), c = d.createElement ("entrada"); a.innerHTML = "<link /> <tabela> </ table> <a href = '/ a' > a </a> <input type = 'checkbox' /> ", l.leadingWhitespace = 3 === a.firstChild.nodeType, l.tbody =! a.getElementsByTagName (" tbody "). comprimento, l.htmlSerializar = a.getElementsByTagName ("link"). length, l.html5Clone = "<: nav> </: nav>"! == d.createElement ("nav"). cloneNode (! 0) .outerHTML, c .type = "checkbox", c.checked =! 0, b.appendChild (c), l.appendChecked = c.checked, a.innerHTML = "<textarea> x </ textarea>", l.noCloneChecked = !! a.cloneNode (! 0) .lastChild.defaultValue, b.appendChild (a), c = d.createElement ("entrada"), c.setAttribute ("tipo", "rádio"), c.setAttribute ("verificado", "checked"), c.setAttribute ("nome", "t"), a.appendChild (c), l.checkClone = a.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, l. noCloneEvent =! a.addEventListener, um [n.expando] = 1, l.attributes =! a.getAttribute (n.expando)} (); var da = {opção: [1, "<select multiple = 'multiple '> "," </ select> "], legend: [1," <fieldset> "," </ fieldset> "], área: [1," <map> "," </ map> "], param: [1, "<objeto>", "</ object>"], thead: [1, "<table>", "</ table>"], tr: [2, "<table> <tbody> "," </ tbody> </ table> "], col: [2," <tabela> <tbody> </ tbody> <colgroup> "," </ colgroup> </ table> "], td: [ 3, "<table> <tbody> <tr>"," </ tr> </ tbody> </ table> "], _ padrão: l.htmlSerialize? [0," "," "]: [1," X <div> "," </ div> " ]}; da.optgroup = da.option, da.tbody = da.tfoot = da.colgroup = da.caption = da.thead, da.th = da.td; function eea (a, b) {var c, d, e = 0, f = "indefinido"! = typeof a.getElementsByTagName? a.getElementsByTagName (b || "*"): "indefinido"! = typeof a.querySelectorAll? a.querySelectorAll (b || "*" ): void 0; if (! f) para (f = [], c = a.childNodes || a; null! = (d = c [e]); e ++)! b || n.nodeName (d, b)? f.push (d): n.merge (f, ea (d, b)); return void 0 === b || b && n.nodeName (a, b) n.merge ([a], f): f} função fa (a, b) {para (var c, d = 0; nulo! = (c = a [d]); d ++) n._data (c, "globalEval",! b || n._data (b [d], "globalEval")) var ga = / <| & #? \ w +; /, ha = / <tbody / i; função ia (a) {Z.test (a.type )&&(uma.defaultChecked = a.checked)} função ja (a, b, c, d, e) {para (var f, g, h, i, j, k, m, o = a.length, p = ca (b) , q = [], r = 0; o> r; r ++) if (g = a [r], g || 0 === g) if ("objeto" === n.type (g)) n .merge (q, g.nodeType? [g]: g); else if (ga.test (g)) {i = i || p.appendChild (b.createElement ("div")), j = ($ .exec (g) || ["", ""]) [1] .toLowerCase (), m = da [j] || da._default, i.innerHTML = m [1] + n.htmlPrefilter (g) + m [2], f = m [0]; enquanto (f -) i = i.lastChild; if (! l.leadingWhitespace && aa.test (g) && q.push (b.createTextNode (aa.exec (g) [0])) ,! l.tbody) {g = "table"! == j || ha.test (g)? "<Table>"! == m [1] || ha.test (g) ? 0: i: i.firstChild, f = g && g.childNodes.length; enquanto (f -) n.nodeName (k = g.childNodes [f], "tbody") &&! K.childNodes.length && g.removeChild ( k)} n.merge (q, i.childNodes), i.textContent = ""; while (i.firstChild) i.removeChild (i.firstChild); i = p.lastChild} else q.push (b.createTextNode (g)); i && p.removeChild (i), l.appendChecked || n.grep (ea (q, "input"), ia), r = 0; while (g = q [r ++]) if (d && n.inArray (g, d)> - 1) e && e.push (g); sen se (h = n.contains (g.ownerDocument, g), i = ea (p.appendChild (g), "script"), h && fa (i), c) {f = 0; enquanto (g = i [f ++]) _. test (g.type || "") && .push (g)} retorna i = null, p}! função () {var b, c, e = d.createElement ("div"); para (b em {enviar:! 0, alterar:! 0, focusin :! 0}) c ​​= "on" + b, (l [b] = c em a) || (e.setAttribute (c, "t"), l [b] = e.atributos [c] .expando ===! 1); e = null} (); var ka = / ^ (?: entrada | select | textarea) $ / i, la = / ^ chave /, ma = / ^ (?: mouse | ponteiro | contextmenu | arrastar | soltar) | clique em /, na = / ^ (?: focusinfocus | focusoutblur) $ /, oa = / ^ ([^.] *) (?: \. (. +) |) /; () {return! 0} function qa () {retorno! 1} função ra () {try {return d.activeElement} catch (a) {}} function sa (a, b, c, d, e, f) {var g, h; if ("objeto" == typeof b) {"string"! = tipo de c && (d = d || c, c = void 0); para (h em b) sa (a, h, c, d, b [h], f); retorne a} if (null == d && null == e? ( e = c, d = c = void 0): null == e && ("string" == typeof c? (e = d, d = void 0) :( e = d, d = c, c = void 0) ), e ===! 1) e = qa; sen se (! e) retornar a; return 1 === f && (g = e, e = function (a) {return n () off (a), g.apply (this, arguments)}, e.guid = g.guid || (g.guid = n.guid ++)), a.each (function () {n.event.add (isto, b, e, d, c)})} n.event = {global: {}, adicione: function (a, b, c, d, e) {var f, g, h, i, j, k, l, m, o , p, q, r = n._data (a); se (r) {c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = n.guid ++), (g = r.eventos) || (g = r.eventos = {}), (k = r.handle) || (k = r.handle = função (a) {retorno "indefinido" == typeof n || a && n.event.triggered === a.type? void 0: n.event.dispatch.apply (k.elem,argumentos)}, k.elem = a), b = (b || ""). correspondência (G) || [""], h = b.length; while (h -) f = oa.exec ( b [h]) || [], o = q = f [1], p = (f [2] || ""). divisão ("."). sort (), o && (j = n.event .especial [o] || {}, o = (e? j.delegateType: j.bindType) || o, j = n.event.special [o] || {}, l = n.extend ({tipo : o, origType: q, dados: d, manipulador: c, guid: c.guid, seletor: e, needsContext: e && n.expr.match.needsContext.test (e), namespace: p.join (".") }, i), (m = g [o]) || (m = g [o] = [], m.delegateCount = 0, j.setup && j.setup.call (a, d, p, k)! =! 1 || (a.addEventListener? A.addEventListener (o, k,! 1): a.attachEvent && a.attachEvent ("em" + o, k))), j.add && (j.add.call (a , l), l.handler.guid || (l.handler.guid = c.guid)), e? m.splice (m.delegateCount ++, 0, l): m.push (l), n.event. global [o] =! 0); a = null}}, remova: function (a, b, c, d, e) {var f, g, h, i, j, k, l, m, o, p , q, r = n.hasData (a) && n._data (a);if (r && (k = r.eventos)) {b = (b || ""). correspondência (G) || [""], j = b.length; enquanto (j -) se (h = oa .exec (b [j]) || [], o = q = h [1], p = (h [2] || ""). dividir ("."). sort (), o) {l = n.event.special [o] || {}, o = (d? l.delegateType: l.bindType) || o, m = k [o] || [], h = h [2] && novo RegExp ("(^ | \\.)" + p.join ("\\. (?:. * \\. |)") + "(\\. | $)"), i = f = m.length ; while (f -) g = m [f] ,! e && q! == g.origType || c && c.guid! == g.guid || h &&! h.test (g.namespace) || d && d! = = g.selector && ("**"! == d ||! g.selector) || (m.splice (f, 1), g.selector && m.delegateCount -, l.remove && l.remove.call (a, g)); i &&! m.length && (l.teardown && l.teardown.call (a, p, r.handle)! ==! 1 || n.removeEvent (a, o, r.handle), excluir k [o ])} else para (o em k) n.event.remove (a, o + b [j], c, d,! 0); n.isEmptyObject (k) && (delete r.handle, n._removeData (a, "events"))}}, trigger: função (b, c, e, f) {varg, h, i, j, l, m, o, p = [e || d], q = k.call (b, "tipo")? b.type: b, r = k.call (b, "espaço de nomes")? b.namespace.split ("."): []; if (i = m = e = e || d, 3! == e.nodeType && 8! == e.nodeType &&! na.test (q + n.event.triggered) && (q.indexOf (".")> - 1 && (r = q.split ("."), q = r.shift (), r.sort ()), h = q.indexOf (":") <0 && "em" + q, b = b [n.expando] ? b: novo n.Event (q, "objeto" == typeof b && b), b.isTrigger = f? 2: 3, b.namespace = r.join ("."), b.rnamespace = b.namespace? new RegExp ("(^ | \\.)" + r.join ("\\. (?:. * \\. |)") + "(\\. | $)"): null, b.result = void 0, b.target || (b.target = e), c = null == c? [b]: n.makeArray (c, [b]), l = n.event.special [q] | | {}, f ||! l.trigger || l.trigger.apply (e, c)! ==! 1)) {if (! f &&! l.noBubble &&! n.isWindow (e)) {para (j = l.delegateType || q, na.test (j + q) || (i = i.parentNode); i; i = i.parentNode) p.push (i), m = i; m === (e.ownerDocument || d) && p.push (m.defaultView || m.parentWindow || a)} o = 0; enquanto ((i = p [o ++] ) &&! b.isPropagationStopped ()) b.type = o> 1? j: l.bindType || q, g = (n._data (i, "eventos") || {}) [b.type] && n ._data (i, "handle"), g && g.apply (i, c), g = h && i [h], g && g.apply && M (i) && (b.result = g.apply (i, c), b.resultado ===! 1 && b.preventDefault ()); if (b.type = q,! F &&! B.isDefaultPrevented () && (! L._default || l._default.apply (p.pop (), c) = ==! 1) && M (e) && h && e [q] &&! N.isWindow (e)) {m = e [h], m && (e [h] = nulo), n.evento.triggerado = q; tente { e [q] ()} captura (s) {} n.event.triggered = void 0, m && (e [h] = m)} retorno b.result}}, dispatch: function (a) {a = n. event.fix (a); var b, c, d, f, g,h = [], i = e.call (argumentos), j = (n._data (isso, "eventos") || {}) [a.type] || [], k = n.event.special [ a.type] || {}; if (i [0] = a, a.delegateTarget = isto,! k.preDispatch || k.preDispatch.call (isto, a)! ==! 1) {h = n .event.handlers.call (isto, a, j), b = 0; enquanto ((f = h [b ++]) &&! a.isPropagationStopped ()) {a.currentTarget = f.elem, c = 0; ((g = f.handlers [c ++]) &&! a.isImmediatePropagationStopped ()) a.rnamespace &&! a.rnamespace.test (g.namespace) || (a.handleObj = g, a.data = g.data, d = ((n.event.special [g.origType] || {}). handle || g.handler) .apply (f.elem, i), void 0! == d && (a.result = d) ===! 1 && (a.preventDefault (), a.stopPropagation ()))} return k.postDispatch && k.postDispatch.call (isto, a), a.result}}, manipuladores: function (a, b) {var c, d, e, f, g = [], h = b.delegateCount, i = a.target; if (h && i.nodeType && ("clique"! == a.type || isNaN (a.button) || a.button <1)) para (; i! = This; i = i.parentNode || this) if (1 === i.nodeType && (i.disabled! ==! 0 || "clique"! == a.type) ) {para (d = [], c = 0; h> c; c ++) f = b [c], e = f.seletor + "", nulo 0 === d [e] && (d [e] = f.needsContext? n (e, isto) .index (i)> - 1: n.find (e, isso, null, [i]). length), d [e] & & d.push (f); d. length &&g.push ({elem: i, manipuladores: d})} return h <b.length &&g.push ({elem: this, manipuladores: b.slice (h)}), g}, correção: function (a) { if (a [n.expando]) retorna a; var b, c, e, f = a.type, g = a, h = esta.fixHooks [f]; h || (this.fixHooks [f] = h = ma.test (f)? this.mouseHooks: la.test (f)? this.keyHooks: {}), e = h.props? this.props.concat (h.props): this.props, a = new n.Event (g), b = e.length; while (b -) c = e [b], a [c] = g [c]; retorno a.target || (a.target = g. srcElement || d), 3 === a.target.nodeType && (a.target = a.target.parentNode), a.metaKey = !! a.metaKey, h.filter? h.filter (a, g): um}, adereços: "altKey bolhas canceláveis ​​ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey destino timeStamp view que ".split (" "), fixHooks: {}, keyHooks: {props:" char charCode key keyCode ".split (" "), filter: function (a , b) {return null == a.which && (a.which = null! = b.charCode? b.charCode: b.keyCode), um}}, mouseHooks: {props: "botões de botões clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement ".split (" "), filtro: função (a, b) {var c, e, f, g = b.button, h = b.fromElement; retorno nulo == a.páginaX && nulo! = b .clientX && (e = a.target.ownerDocument || d, f = e.documentElement, c = e.body, a.pageX = b.clientX + (f && f.scrollLeft || c && c.scrollLeft || 0) - (f && f. clientLeft || c && c.clientLeft || 0), a.pageY = b.clienteY + (f && f.scrollTop || c && c.scrollTop || 0) - (f && f.clientTop || c && c.clientTop || 0)) ,! a.relatedTarget && h && (a.relatedTarget = h === a.target?b.toElement:h), a.which || void 0 === g || (a.which = 1 & g? 1: 2 & g? 3: 4 & g? 2: 0), um}}, especial: {load: {noBubble:! 0}, foco: {trigger: function () {if (this! == ra () && this.focus) try {return this.focus (), 1} catch (a) {}}, delegateType: "focusin"}, blur: {trigger: função ( {return this === ra () && this.blur? (this.blur () ,! 1): void 0}, delegateType: "focusout"}, clique em: {trigger: function () {return n.nodeName ( this, "input") && "checkbox" === this.type && this.click? (this.click () ,! 1): void 0}, _ padrão: function (a) {return n.nodeName (a.target, "a")}}, beforeunload: {postDispatch: function (a) {void 0! == a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)}}},simular: function (a, b, c) {var d = n.extend (novo n.Evento, c, {tipo: a, isSimulado:! 0}); n.event.trigger (d, null, b), d.isDefaultPrevented () && c.preventDefault ()}}, n.removeEvent = d.removeEventListener? função (a, b, c) {a.removeEventListener && a.removeEventListener (b, c)}: function (a, b, c) {var d = "on" + b; a.detachEvent && ("indefinido" == tipoof a [d] && (a [d] = nulo), a.detachEvent (d, c))}, n.Evento = função (a, b) {return this instanceof n.Event? (a && a.type? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a .returnValue ===! 1? pa: qa): this.type = a, b && n.extend (this, b), this.timeStamp = a && a.timeStamp || n.now (), void (isto [n.expando ] =! 0)): new n.Event (a, b)}, n.Event.prototype = {construtor: n.Event, isDefaultPrevented: qa, isPropagationStopped: qa,isImmediatePropagationStopped: qa, preventDefault: function () {var a = this.originalEvent; this.isDefaultPrevented = pa, a && (a.preventDefault? a.preventDefault (): a.returnValue =! 1)}, stopPropagation: function () { var a = this.originalEvent; this.isPropagationStopped = pa, a &&! this.isSimulated && (a.stopPropagation && a.stopPropagation (), a.cancelBubble =! 0)}, stopImmediatePropagation: function () {var a = este.originalEvento; .isImmediatePropagationStopped = pa, a && a.stopImmediatePropagation && a.stopImmediatePropagation (), this.stopPropagation ()}}, n.each ({mouseenter: "mouseover", mouseleave: "mouseout", ponteiroenter: "pointerover", ponteirolinha: "ponteiroout"} , function (a, b) {n.evento.special [a] = {delegateType: b, bindType: b, identificador: function (a) {var c, d = isto, e = a.relatedTarget, f = a. handleObj; return e &&(e === d || n.contains (d, e)) || (a.type = f.origType, c = f.handler.apply (isto, argumentos), a.type = b), c} }}), l.submit || (n.event.special.submit = {configuração: function () {return n.nodeName (this, "form")? 1: void n.event.add (isto, " click._submit keypress._submit ", function (a) {var b = a.target, c = n.nodeName (b," entrada ") || n.nodeName (b," botão ")? n.prop (b , "form"): void 0; c &&! n._data (c, "enviar") && (n.event.add (c, "submit._submit", função (a) {a._submitBubble =! 0}) , n._data (c, "enviar",! 0))})}, postDispatch: function (a) {a._submitBubble && (excluir a._submitBubble, this.parentNode &&! a.isTrigger && n.event.simulate ("enviar" , this.parentNode, a))}, teardown: function () {retornar n.nodeName (this, "form")? 1: void n.event.remove (this, "._ submit")}}), l .change || (n.event.special.change = {setup: function () {return ka.test (this.nodeName)? ("checkbox"! == this.type && "radio"! == this.type || (n.event.add) , "propertychange._change", function (a) {"verificado" === a.originalEvent.propertyName && (this._justChanged =! 0)}), n.event.add (isso, "click._change", function ( a) {this._justChanged &&! a.isTrigger && (this._justChanged =! 1), n.event.simulate ("alterar", this, a)})) ,! 1): void n.event.add (isso, "beforeactivate._change", function (a) {var b = a.target; ka.test (b.nodeName) &&! n._data (b, "alterar") && (n.event.add (b, "alterar ._change ", function (a) {! this.parentNode || a.isSimulated || a.isTrigger || n.event.simulate (" mudança ", this.parentNode, a)}), n._data (b, "change",! 0))})}, identificador: function (a) {var b = a.target; devolva isto!== b || a.isSimulado || a.isTrigger || "radio"! == b.type && "checkbox"! == b.type? a.handleObj.handler.apply (isto, argumentos): void 0} , teardown: function () {return n.event.remove (isso, "._ change"),! ka.test (this.nodeName)}}), l.focusin || n.each ({focus: "focusin" , blur: "focusout"}, função (a, b) {var = função (a) {n.event.simulate (b, a.target, n.event.fix (a))}; n.event. special [b] = {setup: function () {var d = this.ownerDocument || isto, e = n._data (d, b); e || d.addEventListener (a, c,! 0), n. _data (d, b, (e || 0) +1)}, desmontagem: function () {var d = this.ownerDocument || isto, e = n._data (d, b) -1; e? n. _data (d, b, e): (d.removeEventListener (a, c, 0), n.rememData (d, b))}}}), n.fn.extend ({on: function (a, b , c, d) {retorno sa (isto, a, b, c, d)}, um: função (a, b, c, d) {retorno sa (isto, a, b, c, d, 1)} , off: function (a, b, c) {var d, e; if (a && a.preventDefault && a.handleObj) retorna d = a.handleObj, n (a.delegateTarget) .off (d.namespace? d.origType + "." + d.namespace: d.origType, d.selector, d.handler), isto; if ( "objeto" == typeof a) {para (e em a) this.off (e, b, a [e]); retorne isto} return b! ==! 1 && "function"! = typeof b || (c = b, b = void 0), c ===! 1 && (c = qa), this.each (function () {n.event.remove (isso, a, c, b)})}, trigger: function (a, b) {retornar this.each (function () {n.event.trigger (a, b, this)})}, triggerHandler: function (a, b) {var c = este [0]; retorno c ? n.event.trigger (a, b, c, 0): void 0}}); var ta = / jQuery \ d + = "(?: null | \ d +)" / g, ua = new RegExp (" <(?: "+ ba +") [\\ s />] "," i "), va = / <(área ?! | br | col | embed | h | img | entrada | link | meta | param) (([\ w: -] +) [^>] *) \ /> / gi, wa = / <script | <estilo | <link / i, xa = / verificado \ s * (?: [^ =] | = \ s * .checked.) / i, ya = / ^ verdadeiro \ / (. *) /, za = / ^ \ s * <! (?:\ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g, A = ca (d), Ba = Aa.appendChild (d.createElement ("div") ); função Ca (a, b) {retorno n.nodeName (a, "table") && n.nodeName (11! == b.nodeType? b: b.firstChild, "tr")? a.getElementsByTagName ("tbody ") [0] || a.appendChild (a.ownerDocument.createElement (" tbody ")): a} função Da (a) {return a.type = (nulo! == n.find.attr (a," digite ")) +" / "+ a.type, a} function Ea (a) {var b = ya.exec (a.type); retorne b? a.type = b [1]: a.removeAttribute (" digite "), uma função} Fa (a, b) {se (1 === b.nodeType && n.hasData (a)) {var c, d, e, f = n._data (a), g = n. _data (b, f), h = f.eventos; if (h) {excluir g.handle, g.eventos = {}; para (c em h) para (d = 0, e = h [c] .comprimento ; e> d; d ++) n.event.add (b, c, h [c] [d])} g.data && (g.data = n.extend ({}, g.data))}} função (a, b) {var c, d, e; if (1 === b.nodeType) {se (c = b.nodeName.paraLowerCase (),! l.noCloneEvent && b [n.expando]) {e = n._data (b); para (d em e.events) n.removeEvent (b, d, e.handle); b.removeAttribute (n.expando)} "script" === c && b.text! == a.text? (Da (b). texto = a.text, Ea (b)): "objeto" === c? (b.parentNode && (b.outerHTML = a. outerHTML), l.html5Clone && a.innerHTML &&! n.trim (b.innerHTML) && (b.innerHTML = a.innerHTML)): "entrada" === c && Z.test (a.type)? (b.defaultChecked = b .checked = a.checked, b.value! == a.value && (b.value = a.value)): "opção" === c? b.defaultSelected = b.selected = a.defaultSelected: "entrada" ! == c && "textarea"! == c || (b.defaultValue = a.defaultValue)}} função Ha (a, b, c, d) {b = f.apply ([], b); var e , g, h, i, j, k, m = 0, o = a.length, p = o-1, q = b [0], r = n.isFunção (q); se (r || o> 1 && "string" == typeof q &&! L.checkClone && xa.teste (q)) retornar a.each (função (e) {var f = a.eq (e); r && (b [0] = q.call (isto, e, f.html ())), Ha ( f, b, c, d)}); if (o && (k = ja (b, a [0] proprietárioDocumento,! 1, a, d), e = k.firstChild, 1 === k.childNodes. comprimento && (k = e), e || d)) {para (i = n.map (ea (k, "script"), Da), h = i.length; o> m; m ++) g = k, m! == p && (g = n.clone (g,! 0,! 0), h && n.merge (i, ea (g, "script"))), c.call (a [m], g, m ) if (h) para (j = i [i.length-1] .ownerDocument, n.map (i, Ea), m = 0; h> m; m ++) g = i [m], _. teste (g.type || "") &&! n._data (g, "globalEval") && n.contains (j, g) && (g.src? n._evalUrl && n._evalUrl (g.src): n.globalEval ( (g.text || g.textContent || g.innerHTML || ""). substitua (za, ""))); k = e = null} retorne uma função} Ia (a, b, c) {para (var d, e = b? n.filter (b, a): a, f = 0; null! = (d = e [f]); f ++) c || 1! == d.nodeType || n .cleanData (ea (d)), d.parentNode && (c &&n.contains (d.ownerDocument, d) && fa (ea (d, "script")), d.parentNode.removeChild (d)); return a} n.extend ({htmlPrefilter: function (a) {return a. substitua (va, "<$ 1> </ $ 2>")}, clone: ​​function (a, b, c) {var d, e, f, g, h, i = n.contains (a.ownerDocument, a) ; if (l.html5Clone || n.isXMLDoc (a) ||! ua.test ("<" + a.nodeName + ">")? f = a.cloneNode (! 0) :( Ba.innerHTML = a. outerHTML, Ba.removeChild (f = Ba.firstChild)),! (l.noCloneEvent &&l.noCloneChecked || 1! == a.nodeType && 11! == a.nodeType || n.isXMLDoc (a))) para (d = ea (f), h = ea (a), g = 0; nulo! = (e = h [g]); ++ g) d [g] && Ga (e, d [g]), se (b) if (c) para (h = h || ea (a), d = d || e (f), g = 0; nulo! = (e = h [g]); g ++) Fa (e, d [ g]); caso contrário, Fa (a, f); retorna d = ea (f, "script"), d.length> 0 && fa (d,! i && ea (a, "script")), d = h = e = null , f}, cleanData: function (a, b) {para (var d, e, f, g, h = 0, i = n.expando, j = n.cache, k = l.atributos, m = n.evento.special; nulo! = (d = a [h]); h ++) se ((b || M (d)) && (f = d [i], g = f && j [f])) {if (g.eventos) para (e em g.eventos) m [e]? n.evento.remove (d, e): n.removeEvent (d, e, g.handle ); j [f] && (excluir j [f], k || "indefinido" == typeof d.removeAttribute? d [i] = void 0: d.removeAttribute (i), c.push (f)}} }}, n.fn.extend ({domManip: Ha, desanexar: function (a) {return Ia (isso, a,! 0)}, remove: function (a) {retorno Ia (this, a)}, text: function (a) {retornar Y (this, function (a) {return void 0 === a? n.text (this): this.empty (). append ((este [0] && este [0]). ownerDocument || d) .createTextNode (a))}, null, a, arguments.length)}, anexar: function () {return Ha (isto, argumentos, função (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = Ca (isso, a); b.appendChild (a)}})}, prefixado: function () {return Ha ( isso, argumentos, função (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = Ca (isto, a); b.insertBefore (a, b.firstChild)}})}, antes de: function () {return Ha (isto, argumentos, function (a) {this.parentNode && this.parentNode.insertBefore (a, this)})}, depois: function () {return Ha (isto, argumentos, função (a) {this.parentNode && this.parentNode.insertBefore (a, este .nextSibling)})}, vazio: function () {para (var a, b = 0; nulo! = (a = este [b]); b ++) {1 === a.nodeType && n.cleanData (ea (a ,! 1)); while (a.firstChild) a.removeChild (a.firstChild); a.options && n.nodeName (a, "select") && (a.options.length = 0)} retorne este}, clone: function (a, b) {return a = null == a?! 1: a, b = null == b? a: b, this.map (função () {retorno n.clone (isto, a, b) })}, html: function (a) {retorno Y (isto, função (a) {var b = isto [0] || {}, c = 0, d = este.length; if (vazio 0 === a) return 1 === b.nodeType? b.innerHTML.replace (ta, ""): void 0; if ("string"== typeof a &&! wa.test (a) && (l.htmlSerialize ||! ua.test (a)) && (l.leadingWhitespace ||! aa.test (a)) &&! da [($. exec ( a) || ["", ""]) [1] .toLowerCase ()]) {a = n.htmlPrefilter (a); tente {para (; d> c; c ++) b = este [c] || {}, 1 === b.nodeType && (n.cleanData (ea (b,! 1)), b.innerHTML = a); b = 0} captura (e) {}} b && this.empty (). a)}, null, a, arguments.length)}, replaceWith: function () {var a = []; return Ha (isto, argumentos, função (b) {var = this.parentNode; n.inArray (este , a) <0 && (n.cleanData (ea (isto)), c && c.replaceChild (b, isto))}, a)}}), n.each ({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "depois de", replaceAll: "replaceWith"}, function (a, b) {n.fn [a] = function (a) {para (var c, d = 0, e = [ ], f = n (a), h = f.length-1; h> = d; d ++) c = d === h? isto: this.clone (! 0),n (f [d]) [b] (c), g.apply (e, c.get ()); retorne this.pushStack (e)}}; var Ja, Ka = {HTML: "bloco", BODY: "bloco"}; função La (a, b) {var = n (b.createElement (a)). AppendTo (b.body), d = n.css (c [0], "display") ; retorno c.detach (), d} função Ma (a) {var b = d, c = Ka [a]; retorno c || (c = La (a, b), "nenhum"! == c && c | | (Ja = (Ja || n ("<iframe frameborder = '0' largura = '0' altura = '0' />")). AppendTo (b.documentElement), b = (Ja [0] .contentWindow || Ja [0] .contentDocument) .document, b.write (), b.close (), c = La (a, b), Ja.detach ()), Ka [a] = c), c} var Na = / ^ margin /, Oa = novo RegExp ("^ (" + T + ") (! px) [az%] + $", "i"), Pa = função (a, b, c, d ) {var e, f, g = {}; para (f in b) g [f] = a.style [f], a.style [f] = b [f]; e = c.apply (a, d || []); para (f em b) a.style [f] = g [f]; retorne e}, Qa = d.documentElement;! function () {var b, c, e, f, g h, i = d.createElement ("div "), j = d.createElement (" div "); if (j.style) {j.style.cssText =" flutuante: esquerdo; opacidade: .5 ", l.opacity =" 0.5 "=== j .style.opacity, l.cssFloat = !! j.style.cssFloat, j.style.backgroundClip = "caixa de conteúdo", j.cloneNode (! 0) .style.backgroundClip = "", l.clearCloneStyle = "conteúdo -box "=== j.style.backgroundClip, i = d.createElement (" div "), i.style.cssText =" fronteira: 0; largura: 8px; altura: 0; topo: 0; esquerda: -9999px ; padding: 0; margin-top: 1px; posição: absoluto ", j.innerHTML =" ", i.appendChild (j), l.boxSizing =" "=== j.style.boxSizing ||" "== = j.style.MozBoxSizing || "" === j.style.WebkitBoxSizing, n.extend (l, {trustedHiddenOffsets: function () {retorno null == b && k (), f}, boxSizingReliable: function () {retorno null == b && k (), e}, pixelMarginRight: function () {retorno null == b && k (), c},pixelPosition: function () {return null == b && k (), b}, reliableMarginRight: function () {retorno null == b && k (), g}, reliableMarginLeft: function () {retorno null == b && k (), h} }); função k () {var k, l, m = d.documentElement; m.appendChild (i), j.style.cssText = "- dimensionamento de caixa do webkit: caixa de borda; dimensionamento de caixa: borda caixa; posição: relativa; display: bloco; margem: auto; borda: 1px; preenchimento: 1px; topo: 1%; largura: 50% ", b = e = h =! 1, c = g =! 0, a .getComputedStyle && (l = a.getComputedStyle (j), b = "1%"! == (l || {}). top, h = "2px" === (l || {}). marginLeft, e = "4px" === (l || {largura: "4px"}). Largura, j.style.marginRight = "50%", c = "4px" === (l || {marginRight: "4px marginRight, k = j.appendChild (d.createElement ("div")), k.style.cssText = j.style.cssText = "- webkit-box-dimensionamento: content-box; -moz-box -sizing: content-box; box-sizing:content-box; display: bloco; margem: 0; limite: 0; preenchimento: 0 ", k.style.marginRight = k.style.width =" 0 ", j.style.width =" 1px ", g =! parseFloat ((a.getComputedStyle (k) || {}). marginRight), j.removeChild (k)), j.style.display = "nenhum", f = 0 === j.getClientRects (). f && (j.style.display = "", j.innerHTML = "<tabela> <tr> <td> </ td> <td> t </ td> </ tr> </ table>", j.childNodes [0] .style.borderCollapse = "separado", k = j.getElementsByTagName ("td"), k [0] .style.cssText = "margem: 0; borda: 0; preenchimento: 0; display: nenhum", f = 0 === k [0] .offsetHeight, f && (k [0] .style.display = "", k [1] .style.display = "nenhum", f = 0 === k [0] .offsetHeight)), m.removeChild (i)}}} (); var Ra, Sa, Ta = / ^ (parte superior | direita | parte inferior | esquerda) $ /; a.getComputedStyle? (Ra = function (b) { var c = b.ownerDocument.defaultView; return c && c.opener || (c = a), c.getComputedStyle (b)}, Sa = função (a, b, c) {var d, e, f, g, h = a.style; = c || Ra (a), g = c? c.getPropertyValue (b) || c [b]: void 0, ""! == g && void 0! == g || n.contains (a.ownerDocument, a) || (g = n.style (a, b)), c &&! l.pixelMarginRight () && Oa.test (g) && Na.test (b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 === g? g: g + ""}): Qa.currentStyle && (Ra = função (a) {retorno a.currentStyle}, Sa = função (a, b, c) {var d, e, f, g, h = a .style; return c = c || Ra (a), g = c? c [b]: void 0, null == g && h && h [b] && (g = h [b]), Oa.test (g) && ! Ta.test (b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), h.left = "fontSize" === b "1em": g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), void 0 === g? g: g + "" || "auto"}); função Ua (a, b) {return {get: function () {return a ()? void delete this.get: (this.get = b) .apply (isto, argumentos)}}} var Va = / alpha \ ([^)] * \) / Eu, Wa = / opacidade \ s * = \ s * ([^)] *) / i, Xa = / ^ (nenhum | tabela (?! - c [ea]). +) /, Ya = new RegExp ( "^ (" + T + ") (. *) $", "I"), Za = {posição: "absoluto", visibilidade: "oculto", exibição: "bloco"}, $ a = {letterSpacing: "0 ", fontWeight:" 400 "}, _ a = [" Webkit "," O "," Moz "," ms "], ab = d.createElement (" div "). style; função bb (a) {if ( a em ab) retorna a; var b = a.charAt (0) .aUpperCase () + a.slice (1), c = _a.length; while (c-) if (a = _a [c] + b , a em ab) retorna uma função} cb (a, b) {para (var c, d, e, f = [], g = 0, h = a.length; h> g; g ++) d = a [ g], d.style && (f [g] = n._data (d,"olddisplay"), c = d.style.display, b? (f [g] || "nenhum"! == c || (d.style.display = ""), "" === d.style .display && W (d) && (f [g] = n._data (d, "olddisplay", ma (d.nodeName)))) :( e = W (d), (c && "nenhum"! == c | |! e) && n._data (d, "olddisplay", e? c: n.css (d, "display")))) para (g = 0; h> g; g ++) d = a [g] , d.style && (b && "none"! == d.style.display && ""! == d.style.display || (d.style.display = b? f [g] || "": "nenhum" ); return a} função db (a, b, c) {var d = Ya.exec (b); retorno d? Math.max (0, d [1] - (c || 0)) + (d [2] || "px"): b} função eb (a, b, c, d, e) {para (var f = c === (d? "Fronteira": "conteúdo")? 4: " largura "=== b? 1: 0, g = 0; 4> f; f + = 2)" margem "=== c && (g + = n.css (a, c + V [f], 0, e )), d? ("conteúdo" === c && (g- = n.css (a,"preenchimento" + V [f], 0, e)), "margem"! == c && (g- = n.css (a, "borda" + V [f] + "Largura",! 0, e ))): (g + = n.css (a, "preenchimento" + V [f], 0, e), "preenchimento"! == c && (g + = n.css (a, "borda" + V [ f] + "Width",! 0, e))); return g} funç˜ao fb (a, b, c) {var d =! 0, e = "largura" === b? a.offsetWidth: a. offsetHeight, f = Ra (a), g = l.boxSizing && "border-box" === n.css (a, "boxSizing",! 1, f); if (0> = e || null == e ) {se (e = Sa (a, b, f), (0> e || null == e) && (e = a.style [b]), Oa.test (e)) retorne e; d = g && (l.boxSizingReliable () || e === a.style [b]), e = parseFloat (e) || 0} return e + eb (a, b, c || (g? "fronteira": "conteúdo"), d, f) + "px"} n.extend ({cssHooks: {opacidade: {get: function (a, b) {if (b) {var = Sa (a, "opacidade") ; return "" === c? "1": c}}}}, cssNumber:{animationIterationCount:! 0, columnCount:! 0, fillOpacity:! 0, flexGrow:! 0, flexShrink:! 0, fontWeight:! 0, lineHeight:! 0, opacidade:! 0, ordem:! 0, órfãos:! 0 , widows:! 0, zIndex:! 0, zoom:! 0}, cssProps: {"float": l.cssFloat? "cssFloat": "styleFloat"}, estilo: function (a, b, c, d) { if (a && 3! == a.nodeType && 8! == a.nodeType && a.style) {var e, f, g, h = n.camelCase (b), i = a.style; if (b = n.cssProps [h ] || (n.cssProps [h] = bb (h) || h), g = n.cssHooks [b] || n.cssHooks [h], void 0 === c) retorno g && "get" em g && void 0! == (e = g.get (a,! 1, d))? e: i [b]; if (f = tipo de c, "string" === f && (e = U.exec (c ) && e [1] && (c = X (a, b, e), f = "número"), null! = c && c === c && ("número" === f && (c + = e & e [3] | | (n.cssNumber [h]? "": "px")), l.clearCloneStyle || ""! == c || 0! == b.indexOf ("background") || (i [b] = "herdar"),! (g && "set" em g && void 0 === (c = g.set (a, c, d))))) tentar { i [b] = c} captura (j) {}}}, css: funç˜ao (a, b, c, d) {var e, f, g, h = n.camelCase (b); retorno b = n. cssProps [h] || (n.cssProps [h] = bb (h) || h), g = n.cssHooks [b] || n.cssHooks [h], g && "get" em g && (f = g .get (a,! 0, c)), void 0 === f && (f = Sa (a, b, d)), "normal" === f && b em $ a && (f = $ a [b]) , "" === c || c? (e = parseFloat (f), c ===! 0 || isFinite (e)? e || 0: f): f}}), n.each ([ "height", "width"], função (a, b) {n.cssHooks [b] = {get: function (a, c, d) {retornar c? Xa.test (n.css (a, "display ")) && 0 === a.offsetWidth? Pa (a, Za, função () {return fb (a, b, d)}): fb (a, b, d): void 0}, set: function ( a, c, d) {var e = d && Ra (a); retorno db (a, c, d e eb (a, b, d, l.camanhoDeCaixa && "caixa de borda" === n.css (a, "boxSizing ",! 1, e), e): 0)}}}), l.opacity || (n.cssHooks.opacity = {get: function (a, b) {retorno Wa.test ((b && a.currentStyle ? a.currentStyle.filter: a.style.filter) || "") ?. 01 * parseFloat (RegExp. $ 1) + "": b? "1": ""}, conjunto: function (a, b) {var = a.style, d = a.currentStyle, e = n.isNumeric (b)? "alpha (opacidade =" + 100 * b + ")": "", f = d & d.filter || c.filter || ""; c.zoom = 1, (b> = 1 || "" === b) && "" === n.trim (f.replace (Va, "")) && c.removeAttribute && (c .removeAttribute ("filter"), "" === b || d &&! d.filter) || (c.filter = Va.test (f)? f.replace (Va, e): f + "" + e )}}), n.cssHooks.marginRight = Ua (l.reliableMarginRight, function (a, b) {retorno b? Pa (a, {display: "bloco-inline"}, Sa, [a, "marginRight"] ): void 0}), n.cssHooks.marginLeft = Ua (l.reliableMarginLeft, function (a, b) {retorno b? (parseFloat (Sa (a, "marginLeft")) || (n.contains (a.ownerDocument, a)? a.getBoundingClientRect (). Pa-esquerdo (a, {
marginLeft: 0}, function () {return a.getBoundingClientRect (). left}): 0)) + "px": void 0}), n.each ({margin: "", preenchimento: "", borda: "Width"}, função (a, b) {n.cssHooks [a + b] = {expandir: função (c) {para (var d = 0, e = {}, f = "string" == typeof c ? c.split (""): [c]; 4> d; d ++) e [a + V [d] + b] = f [d] || f [d-2] || f [0]; return e}}, Na.test (a) || (n.cssHooks [a + b] .set = db)}), n.fn.extend ({css: function (a, b) {retorno Y , função (a, b, c) {var d, e, f = {}, g = 0; if (n.isArray (b)) {para (d = Ra (a), e = b.length; e > g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d); retorno f} retornar void 0! == c? n.style (a, b, c ): n.css (a, b)}, a, b, argumentos.length> 1)}, show: function () {retorno cb (isso,! 0)}, hide: function () {return cb (isso }}, toggle: function (a) {return "booleano" == typeof a? a? this.show (): this.hide (): this.each (function () {W (isto)? n (este) .show (): n (this) .hide ()})}}); função gb (a, b, c, d,e) {return new gb.prototype.init (a, b, c, d, e)} n.Tween = gb, gb.prototype = {construtor: gb, init: function (a, b, c, d, e , f) {this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur (), este .end = d, this.unit = f || (n.cssNumber [c]? "": "px")}, cur: function () {var a = gb.propHooks [this.prop]; retorna a && a. get.a.get (this): gb.propHooks._default.get (this)}, execute: function (a) {var b, c = gb.propHooks [this.prop]; retorne this.options.duration? .pos = b = n.easing [this.easing] (a, this.options.duration * a, 0,1, this.options.duration): this.pos = b = a, this.now = (isto. end-this.start) * b + this.start, this.options.unit = f || (n.cssNumber [c]? "": "px")}, cur: function () {var a = gb.propHooks [this.prop]; retorna a && a.get? a.get (isto ): gb.propHooks._default.get (this)}, execute: function (a) {var b, c = gb.propHooks [this.prop]; retorne this.options.duration? this.pos = b = n. easing [this.easing] (a, this.options.duration * a, 0,1, this.options.duration): this.pos = b = a, this.now = (this.end-this.start) * b + this.start, this.options.unit = f || (n.cssNumber [c]? "": "px")}, cur: function () {var a = gb.propHooks [this.prop]; retorna a && a.get? a.get (isto ): gb.propHooks._default.get (this)}, execute: function (a) {var b, c = gb.propHooks [this.prop]; retorne this.options.duration? this.pos = b = n. easing [this.easing] (a, this.options.duration * a, 0,1, this.options.duration): this.pos = b = a, this.now = (this.end-this.start) * b + this.start, this.options.step && this.options.step.call (this.elem, this.now, this), c && c.set? c.set (this): gb.propHooks._default.set (this), este}}, gb.prototype.init .prototype = gb.prototype, gb.propHooks = {_ padrão: {get: function (a) {var b; retorno 1! == a.elem.nodeType || null! = a.elem [a.prop] && null = = a.elem.style [a.prop]? a.elem [a.prop] :( b = n.css (a.elem, a.prop, ""), b && "auto"! == b? b : 0)}, set: function (a) {n.fx.step [a.prop]? N.fx.step [a.prop] (a): 1! == a.elem.nodeType || null = = a.elem.style [n.cssProps [a.prop]] &&! n.cssHooks [a.prop]? a.elem [a.prop] = a.now: n.style (a.elem, a. prop, a.now + a.unit)}}}, gb.propHooks.scrollTop = gb.propHooks.scrollLeft = {definir: function (a) {a.elem.nodeType && a.elem.parentNode && (a.elem [a. prop] = a.now)}}, n.easing = {linear: function (a) {retorno a}, swing: function (a) {return.5-Math.cos (a * Math.PI) / 2} , _default: "swing"}, n.fx = gb.prototype.init, n.fx.step = {}; var hb, ib, jb = / ^ (?: alternar | mostrar | ocultar) $ /, kb = / queueHooks $ /; function lb () { return a.setTimeout (function () {hb = void 0}), hb = n.now ()} funcao mb (a, b) {var c, d = {altura: a}, e = 0; para (b = b? 1: 0; 4> e; e + = 2-b) c = V [e], d ["margem" + c] = d ["preenchimento" + c] = a; retorno b && (d.opacity = d.width = a), d} função nb (a, b, c) {para (var d, e = (qb.tweeners [b] || []). concat (qb.tweeners ["*"] ), f = 0, g = e.length; g> f; f ++) if (d = e [f] .call (c, b, a)) retorno d} função ob (a, b, c) {var d, e, f, g, h, i, j, k, m = isto, o = {}, p = a.style, q = a.nodeType && W (a), r = n._data (a, "fxshow "); c.queue || (h = n._queueHooks (a," fx "), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {h.unqueued || i ()}), h.unqueued ++, m.always (função () {m.always (function () {h.unqueued -, n.queue (a, "fx") .length || h.empty.fire ()})})), 1 === a.nodeType && ("height" em b || "width" em b) && (c.overflow = [p.overflow, p.overflowX, p.overflowY], j = n.css (a, "display"), k = "nenhum" === j? n._data (a, "olddisplay") || Ma (a.nodeName): j, "inline" === k && "nenhum" === n.css (a, "float ") && (l.inlineBlockNeedsLayout &&" inline "! == Ma (a.nodeName)? p.zoom = 1: p.display =" bloqueio de linha ")), c.overflow && (p.overflow =" oculto ", l.shrinkWrapBlocks () || m.always (function () {p.overflow = c.overflow [0], p.overflowX = c.overflow [1], p.overflowY = c.overflow [2]})) para (d em b) se (e = b [d], jb.exec (e)) {se (excluir b [d], f = f || "alternar" === e, e === ( q "esconder": "mostrar")) {if ("show"! == e ||! r || void 0 === r [d]) continuar; q =! 0} o [d] = r && r [d] || n.style (a, d)} mais j = void 0; if (n.isEmptyObject (o)) "inline "=== (" nenhum "=== j? Ma (a.nodeName): j) && (p.display = j); else {r?" oculto "em r && (q = r.hidden): r = n._data (a, "fxshow", {}), f && (r.shidden =! q), q? n (a) .show (): m.done (function () {n (a). ()}), m.done (function () {var b; n._removeData (a, "fxshow"); para (b em o) n.style (a, b, o [b])}); (d em o) g = nb (q? r [d]: 0, d, m), d em r || (r [d] = g.start, q && (g.end = g.start, g. start = "width" === d || "height" === d? 1: 0))}} function pb (a, b) {var c, d, e, f, g; ) se (d = n.camelCase (c), e = b [d], f = a [c], n.isArray (f) && (e = f [1], f = a [c] = f [ 0]), c! == d && (a [d] = f, apaga a [c]), g = n.cssHooks [d], g && "expandir" em g) {f = g.expand (f), delete a [d]; para (c in f) c em a || (a [c] = f [c], b [c] = e)} mais b [d] = e} função qb (a, b , c) {var d, e, f = 0, g = qb.prefilters.length, h = n.Deferred (). sempre (function () {delete i.elem}),i = function () {se (e) retorna! 1; para (var b = hb || lb (), c = Math.max (0, j.startTime + j.duração-b), d = c / j .duration || 0, f = 1-d, g = 0, i = j.tweens.length; i> g; g ++) j.tweens [g] .run (f); retorno h.notificarCom (a, [ j, f, c]), 1> f && i? c: (h.resolveWith (a, [j]) ,! 1)}, j = h.promise ({elem: a, props: n.extend ({}) b) opts: n.extend (! 0, {specialEasing: {}, easing: n.easing._default}, c), originalPropriedades: b, originalOptions: c, startTime: hb || lb (), duração: c.duration, tweens: [], createTween: function (b, c) {var d = n.Tween (a, j.opts, b, c, j.opts.specialEasing [b] || j.opts.easing ); return j.tweens.push (d), d}, stop: funç˜ao (b) {var c = 0, d = b j comprimento.tweens: 0; se (e) retornar isto, para (e = ! 0; d> c; c ++) j.tweens [c] .run (1); return b? (H.notifyWith (a, [j, 1.0]), h.resolveCom (a, [j, b ])): h.rejectWith (a, [j, b]), isto}}), k = j.props; para (pb (k, j.opts.specialEasing); g> f; f ++) if (d = qb.prefilters [f] .call (j, a, k, j.opts)) return n.isFunction (d.stop) && (n._queueHooks (j.elem, j.opts.queue) .stop = n.proxy (d.stop, d)), d; retorno n.map (k, nb, j), n.isFunção (j.opts.start) && j.opts.start.call (a, j), n.fx.timer (n.extend (i, {elem: a, anim: j, fila: j.opts.queue}) ), j.progress (j.opts.progress) .done (j.opts.done, j.opts.complete) .fail (j.opts.fail) .sempre (j.opts.always)} n.Animation = n.extend (qb, {tweeners: {"*": [função (a, b) {var c = this.createTween (a, b); retorno X (c.elem, a, U.exec (b), c), c}]}, tweener: function (a, b) {n.isFunction (a)? (b = a, a = ["*"]): a = a.match (G); para (var c, d = 0, e = a.length; e> d; d ++) c = a [d], qb.tweeners [c] = qb.tweeners [c] || [], qb.tweeners [c]. unshift (b)}, prefilters: [ob], prefilter: função (a, b) {b? qb.prefilters.unshift (a): qb.prefilters.push (a)}}), n.speed = função ( a, b, c) {var d = a && "objeto" == tipoof a? n.extend ({}, a): {completo: c ||! c && b || n.isFunção (a) && a,duração: a, atenuação: c && b || b &&! n.isFunção (b) && b}; retorno d.duração = n.fx.off 0: "número" == tipo de d.duração? d.duração: d.duração em n.fx.speeds? n.fx.speeds [d.duração]: n.fx.speeds._default, nulo! = d.queue && d.queue! ==! 0 || (d.queue = "fx") , d.old = d.complete, d.complete = function () {n.isFunction (d.old) && d.old.call (este), d.queue && n.dequeue (this, d.queue)}, d} , n.fn.extend ({fadeTo: função (a, b, c, d) {retornar this.filter (W) .css ("opacidade", 0) .show (). end (). animar ({opacidade : b, a, c, d)}, animar: function (a, b, c, d) {var e = n.isEmptyObject (a), f = n.speed (b, c, d), g = function () {var b = qb (isso, n.extenda ({}, a), f); (e || n._data (isso, "fim")) && b.stop (! 0)}; retorno g .finish = g, e || f.queue ===! 1? this.each (g): this.queue (f.queue, g)}, stop: função (a, b, c) {var d = function (a) {var b = a.stop; delete a.stop, b (c)};return "string"! = typeof a && (c = b, b = a, a = void 0), b && a! ==! 1 && this.queue (a || "fx", []), this.each (function () {var b =! 0, e = null! = a && a + "queueHooks", f = n.timers, g = n._data (isto); se (e) g [e] && g [e] .stop && d (g [e ]; else para (e em g) g [e] && g [e] .stop && kb.test (e) & d (g [e]); para (e = f.length; e -;) f [e] .elem! == isso || null! = a && f [e] .queue! == a || (f [e] .anim.stop (c), b =! 1, f.splice (e, 1)) ;! b && c || n.dequeue (isso, a)})}, finish: function (a) {return a! ==! 1 && (a = a || "fx"), this.each (function () { var b, c = n._data (isto), d = c [a + "fila"], e = c [a + "filaHooks"], f = n.timers, g = d? d.length: 0; c.finish =! 0, n.queue (isto, a, []), e && e.stop && e.stop.call (isto,! 0), b = f.length; b -;) f [b] .elem === this && f [b] .queue === a && (f [b] .anim.stop (! 0), f.splice (b, 1)); para (b = 0; g> b; b ++) d [b] & d [b] .finish && d [b] .finish.call (isto); delete c.finish})}}) , n.each (["toggle", "show", "hide"], função (a, b) {var = n.fn [b]; n.fn [b] = função (a, d, e ) {return null == a || "booleano" == typeof a? c.apply (isto, argumentos): this.animate (mb (b,! 0), a, d, e)}}), n. each ({slideDown: mb ("mostrar"), slideUp: mb ("ocultar"), slideToggle: mb ("alternar"), fadeIn: {opacidade: "mostrar"}, fadeOut: {opacidade: "ocultar"}, fadeToggle: {opacidade: "toggle"}}, function (a, b) {n.fn [a] = função (a, c, d) {retorno this.animate (b, a, c, d)}}) , n.timers = [], n.fx.tick = function () {var a, b = n.timers, c = 0; para (hb = n.now (); c <b.length; c ++) a = b [c], a () || b [c]! == a || b.splice (c -, 1); b.length || n.fx.stop (), hb = void 0} , n.fx.timer = function (a) {n.timers.push (a), a ()? n.fx.start (): n.timers.pop ()}, n.fx.interval = 13, n.fx.start = function () {ib || (ib = a.setInterval (n.fx.tick, n.fx.interval))}, n.fx.stop = function () {a.clearInterval (ib), ib = null}, n.fx.speeds = {lento: 600, rápido: 200, _default: 400}, n.fn.delay = função (b, c) {retorno b = n.fx? n.fx.speeds [b] || b: b, c = c || "fx", this.queue (c, função (c, d) {var e = a.setTimeout (c, b); d.stop = função () {a.clearTimeout (e)}}}}, function () {var a, b = d.createElement ("entrada"), c = d.createElement ("div"), e = d.createElement ("select" ), f = e.appendChild (d.createElement ("option")); c = d.createElement ("div"), c.setAttribute ("className", "t"), c.innerHTML = "<link / <table> </ table> <a href='/a'> a </a> <input type = 'checkbox' /> ", a = c.getElementsByTagName (" a ") [0], b.setAttribute ("tipo", "caixa de seleção"), c.appendChild (b),a = c.getElementsByTagName ("a") [0], a.style.cssText = "início: 1px", l.getSetAttribute = "t"! == c.className, l.style = / top / .test ( a.getAttribute ("style")), l.hrefNormalized = "/ a" === a.getAttribute ("href"), l.checkOn = !! b.value, l.optSelected = f.selecionado, l. enctype = !! d.createElement ("form"). enctype, e.disabled =! 0, l.optDisabled =! f.disabled, b = d.createElement ("entrada"), b.setAttribute ("valor", ""), l.input = "" === b.getAttribute ("valor"), b.value = "t", b.setAttribute ("tipo", "rádio"), l.radioValue = "t" === b.value} (); var rb = / \ r / g, sb = / [\ x20 \ t \ r \ n \ f] + / g; n.fn.extend ({val: function (a ) {var b, c, d, e = isto [0]; {if (arguments.length) retorna d = n.isFunction (a), this.each (função (c) {var e; 1 === isto .nodeType && (e = d? a.call (isto, c, n (isto) .val ()): a,null == e? e = "": "numero" == typeof e? e + = "": n.isArray (e) && (e = n.map (e, funcao (a) {retorno null == a? "": a + ""})), b = n.valHooks [this.type] || n.valHooks [this.nodeName.toLowerCase ()], b && "set" em b && void 0! == b.set (este , e, "valor") || (this.value = e))}); if (e) retorna b = n.valHooks [e.type] || n.valHooks [e.nodeName.toLowerCase ()], b && "get" em b && void 0! == (c = b.get (e, "valor"))? c: (c = e.value, "string" == tipo de c? c.replace (rb, "" ): null == c? "": c)}}}), n.extend ({valHooks: {opção: {get: function (a) {var b = n.find.attr (a, "valor") ; return null! = b? b: n.trim (n) (a)). replace (sb, "")}}, selecione: {get: function (a) {para (var b, c, d = a.options, e = a.selectedIndex, f = "selecionar-one" === a.type || 0> e, g = f? null: [], h = f? e + 1: d.length,i = 0> eh: f e: 0; h> i; i + +) if (c = d [i], (c.selecionado || i === e) && (l.optDisabled?! c. disabled: null === c.getAttribute ("disabled")) && (! c.parentNode.disabled ||! n.nodeName (c.parentNode, "optgroup"))) {se (b = n (c). val (), f) return b; g.push (b)} retorno g}, conjunto: function (a, b) {var c, d, e = a.options, f = n.makeArray (b), g = e.length; while (g -) se (d = e [g], n.inArray (n.valHooks.option.get (d), f)> - 1) tente {d.selected = c =! 0} catch (h) {d.scrollHeight} else d.selected =! 1; return c || (a.selectedIndex = -1), e}}}}), n.each (["radio", "checkbox "], function () {n.valHooks [this] = {definir: function (a, b) {retornar n.isArray (b)? a.checked = n.inArray (n (a) .val (), b )> - 1: void 0}}, l.checkOn || (n.valHooks [isto] .get = function (a) {retorno nulo === a.getAttribute ("valor")? "Em": a. valor})}); var tb, ub, vb = n.expr.attrHandle, wb = / ^ (?: verificado | selecionado) $ / i, xb = l.getSetAttribute, yb = l.input; n.fn.extend ({attr: function (a, b) {retornar Y (isso, n.attr, a, b, argumentos.length> 1)}, removeAttr: function (a {return this.each (function () {n.removeAttr (this, a)})}}), n.extend ({attr: function (a, b, c) {var d, e, f = a. nodeType; if (3! == f && 8! == f && 2! == f) retorna "indefinido" == typeof a.getAttribute? n.prop (a, b, c): (1 === f && n.isXMLDoc (a ) || (b = b.toLowerCase (), e = n.attrHooks [b] || (n.expr.match.bool.test (b)? ub: tb)), nulo 0! == c? null === c? void n.removeAttr (a, b): e && "set" em e && void 0! == (d = e.set (a, c, b)) d: (a.setAttribute (b, c + ""), c): e && "get" em e && null! == (d = e.get (a, b)) d: (d = n.find.attr (a, b), null = = d? void 0: d))}, attrHooks: {tipo: {set: function (a, b) {if (! l.radioValue && "radio" === b && n.nodeName (a, "input")) {var = a.value; retorno a.setAttribute ("type", b), c && (a.value = c), b}}}}, removeAttr: function (a, b) {var c, d, e = 0, f = b && b.match (G) ; if (f && 1 === a.nodeType) while (c = f [e ++]) d = n.propFix [c] || c, n.expr.match.bool.test (c)? yb && xb ||! wb .test (c)? a [d] =! 1: a [n.camelCase ("padrão -" + c)] = a [d] =! 1: n.attr (a, c, ""), a .removeAttribute (xb? c: d)}}), ub = {conjunto: function (a, b, c) {retornar b ===! 1? n.removeAttr (a, c): yb && xb ||! wb. teste (c)? a.setAttribute (! xb && n.propFix [c] || c, c): a [n.camelCase ("padrão -" + c)] = a [c] =! 0, c}}, n.each (n.expr.match.bool.source.match (/ \ w + / g), função (a, b) {var = vb [b] || n.find.attr; yb && xb ||! wb .teste (b)? vb [b] = funç˜ao (a, b, d) {var e, f; retorno d || (f = vb [b], vb [b] = e, e = nulo! = c (a, b, d)? b.toLowerCase (): null, vb [b] = f), e}: vb [b] = função (a, b, c) {retorno c? void 0: a [n .camelCase ("default -" + b)]? b.toLowerCase (): null}}), yb && xb || (n.attrHooks.value = {definir: function (a, b, c) {retornar n.nodeName (a, "input")? void (a.defaultValue = b): tb && tb.set (a, b , c)}}), xb || (tb = {set: function (a, b, c) {var d = a.getAttributeNode (c); retorno d || a.setAttributeNode (d = a.ownerDocument.createAttribute (c)), d.value = b + = "", "valor" === c || b === a.getAttribute (c)? b: void 0}}, vb.id = vb.name = vb .coords = function (a, b, c) {var d; retorno c? void 0: (d = a.getAttributeNode (b)) && ""! == d.value? d.value: null}, n. valHooks.button = {get: function (a, b) {var = a.getAttributeNode (b); return c && c.specified? c.value: void 0}, conjunto: tb.set}, n.attrHooks.contenteditable = {set: function (a, b, c) {tb.set (a, "" === b?! 1: b, c)}}, n.each (["largura", "altura"], função (a, b) {n.attrHooks [b] = {definir: function (a, c) {retorno "" === c? (a.setAttribute (b, "auto"), c): void 0}} })),eu.style || (n.attrHooks.style = {get: function (a) {retornar a.style.cssText || void 0}, set: function (a, b) {retornar a.style.cssText = b + ""} }); var zb = / ^ (?: input | select | área de texto | botão | objeto) $ / i, Ab = / ^ (?: a | área) $ / i; n.fn.extend ({prop: function (a, b) {retornar Y (isto, n.prop, a, b, argumentos.length> 1)}, removeProp: function (a) {retornar a = n.propFix [a] || a, this.each (function () {try {this [a] = void 0, delete este [a]} catch (b) {}})}}), n.extend ({prop: função (a, b, c) {var d, e, f = a.nodeType; if (3! == f && 8! == f && 2! == f) return 1 === f && n.isXMLDoc (a) || (b = n.propFix [b] || b, e = n.propHooks [b]), void 0! == c? e && "set" em e && void 0! == (d = e.set (a, c, b))? d: a [b] = c: e && "get" em e && null! == (d = e.get (a, b))? d: a [b]}, propHooks: {tabIndex: {get: função (a) {var b = n .find.attr (a, "tabindex"); retorno b? parseInt (b, 10): zb.test (a.nodeName) || Ab.test (a.nodeName) && a.href? 0: -1}}}, propFix: {"para": "htmlFor", "class": "className"}}), l.hrefNormalized || n.each (["href", "src"], function (a, b) {n.propHooks [b] = {get: function (a) {retorno a.getAttribute (b, 4)}}}), l.optSelected || (n.propHooks .selected = {get: function (a) {var b = a.parentNode; retorno b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), nulo}, conjunto: function (a) {var b = a.parentNode b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex)}}, n.each (["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan "," useMap "," frameBorder "," contentEditable "], function () {n.propFix [this.toLowerCase ()] = este}), l.enctype || (n.propFix.enctype ="codificação "); var Bb = / [\ t \ r \ n \ f] / g; função Cb (a) {retorno n.attr (a," classe ") ||" "} n.fn.extend ({ addClass: function (a) {var b, c, d, e, f, g, h, i = 0; se (n.isFunction (a)) retornar this.each (function (b) {n (this). addClass (a.call (isso, b, Cb (this)))}); if ("string" == typeof a && a) {b = a.match (G) || []; while (c = isso [i ++ ]) if (e = Cb (c), d = 1 === c.nodeType && ("" + e + "") .replace (Bb, "")) {g = 0; enquanto (f = b [g ++] ) d.indexOf ("+ f +" ") <0 && (d + = f +" "); h = n.trim (d), e! == h && n.attr (c," classe ", h)}} this}, removeClass: function (a) {var b, c, d, e, f, g, h, i = 0; se (n.isFunction (a)) retornar this.each (function (b) {n ( isto) .removeClass (a.call (isto, b, Cb (this)))}); if (! arguments.length) retorna this.attr ("class", ""); if ("string" == typeof a && a) {b = a.match (G) || []; while (c = isso [i ++]) if (e = Cb (c), d = 1 === c.nodeType && ("" + e + "") .replace (Bb, " ")) {g = 0; while (f = b [g ++]) enquanto (d.indexOf (" "+ f +" ")> - 1) d = d.replace (" "+ f +" "," ") ; h = n.trim (d), e! == h && n.attr (c, "classe", h)}} retornar isto}, toggleClass: function (a, b) {var c = tipo de um; return "booleano "== typeof b &&" string "=== c? b? this.addClass (a): this.removeClass (a): n.isFunction (a)? this.each (função (c) {n (isto). toggleClass (a.call (isso, c, Cb (isto), b), b)}): this.each (function () {var b, d, e, f; if ("string" === c) {d = 0, e = n (isto), f = a.match (G) || []; enquanto (b = f [d ++]) e.hasClass (b)? e.removeClass (b): e. addClass (b)} else void 0! == a && "boolean"! == c || (b = Cb (this), b && n._data (isso, "__ className __", b), n.attr (isso, "class "b || a ===! 1? "": n._data (isso, "__ nome_da_classe __") || ""))})}, hasClass: function (a) {var b, c, d = 0; b = "" + a + ""; while (c = isto [d ++]) if (1 === c.nodeType && ("" + Cb (c) + "") .replace (Bb, "") .indexOf (b )> - 1) return! 0; return! 1}}), n.each ("desfocagem foco focusin focusout carga redimensionar scroll descarregar click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mudança de lista de reprodução select submit keydown keypress erro de formatação contextmenu" .split ( ""), function (a, b) {n.fn [b] = função (a, c) {retorno arguments.length> 0? this.on (b, nulo, a, c): this.trigger (b )}}), n.fn.extend ({hover: function (a, b) {retornar this.mouseenter (a) .mouseleave (b || a)}}; var Db = a.location, Eb = n .now (), Fb = / \? /, Gb = / (,) | (\ [| {) | (} |]) | "(?: [^" \\\ r \ n] | \\ [ "\\\ / bfnrt] | \\ u [\ da-fA-F] {4}) *" \ s *:true | false | null | - | (! 0 \ d) \ d + (?: \. \ d + |) (?: [eE] [+ -]? \ d + |) / g;n.parseJSON= function (b) {if (a.JSON && a.JSON.parse) retorna a.JSON.parse (b + ""); var c, d = nulo, e = n.trim (b + ""); return e &&! n. trim (e.replace (Gb, função (a, b, e, f) {retorno c && b && (d = 0), 0 === d? a: (c = e || b, d + =! f-! e , "")}))? Function ("return" + e) ​​(): n.error ("JSON inválido:" + b)}, n.parseXML = função (b) {var c, d; if (! b || "string"! = typeof b) retornar null; tente {a.DOMParser? (d = novo a.DOMParser, c = d.parseFromString (b, "text / xml")) :( c = novo a. ActiveXObject ("Microsoft.XMLDOM"), c.async = "false", c.loadXML (b))} catch (e) {c = void 0} return c && c.documentElement &&! C.getElementsByTagName ("parsererror"). || n.error ("XML inválido:" + b), c}; var Hb = / #. * $ /, Ib = / ([? &]) _ = [^ &] * /, Jb = / ^ (.*?): [\ t] * ([^ \ r \ n] *) \ r? $ / gm, Kb = / ^ (?: sobre | app | app-armazenamento |. + - extensão | arquivo | res | widget): $ /, Lb = / ^ (?: GET | HEAD) $ /, Mb = / ^ \ / \ //, Nb = / ^ ([\ w + -] +:) (?: \ / \ / (?: [^ \ /? #] * @ |) ([^ \ /? #:] *) (? :: (\ d +) |) |) /, Ob = {}, Pb = {} , Qb = "* /". Concat ("*"), Rb = Db.href, Sb = Nb.exec (Rb.toLowerCase ()) || []; função Tb (a) {função de retorno (b, c ) {"string"! = typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase (). correspondência (G) || []; if (n.isFunção (c)) enquanto (d = f [e ++]) "+" === d.charAt (0)? (d = d.slice (1) || "*", (a [d] = a [d ] || []). unshift (c)) :( a [d] = a [d] || []). função push (c)}} Ub (a, b, c, d) {var e = {}, f = a === Pb; função g (h) {var i; return e [h] =! 0, n.each (a [h] || [], função (a, h) {var j = h (b, c, d); return "string"! = typeof j || f || e [j]? f?! (i = j): void 0: (b.dataTypes.unshift (j) , g (j) ,! 1)}), i} return g (b.dataTypes [0]) ||! e ["*"] && g ("*")} function Vb (a, b) {var c, d, e = n.ajaxSettings.flatOptions || {}; para (d em b) void 0! == b [d] && ((e [d]? a: c || (c = {})) [d] = b [d]); retorno c && n.extend (! 0, a, c), a} função Wb (a, b, c) {var d, e, f, g, h = a.contents, i = a.dataTypes; while ("*" === i [0]) i.shift (), void 0 === e && (e = a.mimeType | | b.getResponseHeader ("Content-Type")); if (e) para (g em h) if (h [g] && h [g] .test (e)) {i.unshift (g); break} se (i [0] em c) f = i [0]; sen {para (g em c) {se (! i [0] || a.converters [g + "" + i [0]]) {f = g | break} d || (d = g)} f = f || d} return f? (f! == i [0] && i.unshift (f), c [f]): void 0} função Xb (a, b, c, d) {var e, f, g, h, i, j = {}, k = a.dataTypes.slice (); if (k [1]) para (g em a.converters j [g.toLowerCase ()] = a.converterios [g]; f = k.shift (); enquanto (f) if (a.responseFields [f] && (c [a.responseFields [f]] = b i && d && a.dataFilter && (b = a.dataFilter (b, a.dataType)), i = f, f = k.shift ()) if ("*" === f) f = i; else if ("*"! == i && i! == f) {if (g = j [i + "" + f] || j [ "*" + f] ,! g) para (e em j) se (h = e.split (""), h [1] === f && (g = j [i + "" + h [0]] || j ["*" + h [0]])) {g ===! 0? g = j [e]: j [e]! ==! 0 && (f = h [0], k.unshift (h [1])); break} se (g! ==! 0) if (g && a ["lança"]) b = g (b); senão tente {b = g (b)} pegar (l) { return {estado: "parsererror", erro: g? l: "Nenhuma conversão de" + i + "para" + f}}} return {estado: "sucesso", dados: b}} n.extend ({ativo: 0 , lastModified: {}, etag: {}, ajaxSettings: {url: Rb, digite: "GET", isLocal: Kb.test (Sb [1]), global:! 0, processData:! 0, assíncrono:! 0 , contentType: "aplicativo / x-www-form-urlencoded; charset = UTF-8", aceita: {"*": Qb, texto: "text / plain", html: "text / html", xml: "aplicativo / xml, text / xml ",json: "aplicativo / json, texto / javascript"}, conteúdo: {xml: / \ bxml \ b /, html: / \ bhtml / json: / \ bjson \ b /}, responseFields: {xml: "responseXML" , texto: "responseText", json: "responseJSON"}, conversores: {"* texto": String, "texto html":! 0, "texto json": n.parseJSON, "texto xml": n.parseXML} , flatOptions: {url:! 0, contexto:! 0}}, ajaxSetup: function (a, b) {retorno b? Vb (Vb (a, n.ajaxConfigurações), b): Vb (n.ajaxConfigurações, a) }, ajaxPrefilter: Tb (Ob), ajaxTransporte: Tb (Pb), ajax: function (b, c) {"objeto" == typeof b && (c = b, b = void 0), c = c || {} ; var d, e, f, g, h, i, j, k, l = n.ajaxSetup ({}, c), m = l.context || l, o = l.context && (m.nodeType || m.jquery)? n (m): n.evento, p = n.Deferred (), q = n.Callbacks ("uma vez memória"), r = l.statusCode || {}, s = {}, t = {}, u = 0, v = "cancelado", w = {readyState: 0, getResponseHeader: function (a) {var b;if (2 === u) {if (! k) {k = {}; enquanto (b = Jb.exec (g)) k [b [1] .paraLowerCase ()] = b [2]} b = k [a.toLowerCase ()]} return null == b? null: b}, getAllResponseHeaders: function () {retorno 2 === u? g: nulo}, setRequestHeader: function (a, b) {var c = a.toLowerCase (); return u || (a = t [c] = t [c] || a, s [a] = b), isto}, overrideMimeType: function (a) {retorno u || (l .mimeType = a), this}, statusCode: function (a) {var b; if (a) se (2> u) para (b em a) r [b] = [r [b], a [b] ]; senão w.always (a [w.status]); retorna isto}, abort: function (a) {var b = a || v; return j && j.abort (b), y (0, b), isto }}; if (p.promise (w) .complete = q.add, w.success = w.done, w.error = w.fail, l.url = ((b || l.url || Rb) + ""). replace (Hb, ""). substitua (Mb, Sb [1] + "//"), l.type = c.method || c.type || l.method || l.type , l.dataTypes = n.trim (l.dataType || "*"). toLowerCase (). match (G) || [""], nulo == l.crossDomain && (d = Nb.exec (l.url) .toLowerCase ()), l.crossDomain =! (! d || d [1] === Sb [1] && d [2] === Sb [2] && (d [3] || ("http:" === d [1] "80": "443")) === (Sb [3] || ("http:" === Sb [1]? "80": "443")))), l.data && l.processData && "string"! = typeof l.data && (l.data = n.param (l.data, l.tradicional)), Ub (Ob, l, c, w), 2 === u) retorno w; i = n.event && l.global, i && 0 === n.active ++ && n.event.trigger ("ajaxStart"), l.type = l.type.toUpperCase (), l.hasContent =! Lb.test (l.type ), f = l.url, l.hasContent || (l.data && (f = l.url + = (Fb.test (f)? "&": "?") + l.data, excluir l.data) , l.cache ===! 1 && (l.url = Ib.test (f)? f.replace (Ib, "$ 1 _ =" + Eb ++): f + (Fb.test (f)? "&": " ? ") +" _ = "+ Eb ++)), l.ifModified && (n.lastModified [f] && w.setRequestHeader ("If-Modified-Since ", n.lastModified [f]), n.etag [f] && w.setRequestHeader (" If-Nenhum-Correspondência ", n.etag [f])), (l.data && l.hasContent && l.contentType ! ==! 1 || c.contentType) && w.setRequestHeader ("Tipo de Conteúdo", l.contentType), w.setRequestHeader ("Aceitar", l.dataTypes [0] && l.accepts [l.dataTypes [0] ]? l.accepts [l.dataTypes [0]] + ("*"! == l.dataTypes [0]? "," + Qb + "; q = 0,01": ""): l.accepts ["* "]); for (e em l.headers) w.setRequestHeader (e, l.headers [e]); if (l.beforeSend && (l.beforeSend.call (m, w, l) ===! 1 | | 2 === u)) return w.abort (); v = "abort"; para (e em {sucesso: 1, erro: 1, completo: 1}) w [e] (l [e]); if (j = Ub (Pb, l, c, w)) {se (w.readyState = 1, i && o.trigger ("ajaxSend", [w, l]), 2 === u) retorna w; l. async && l.timeout> 0 && (h = a.setTimeout (function () {w.abort ("timeout")}, l.timeout)); tente {u = 1, j.send (s, y)} catch (x) {se (! (2> u) ) throw x; y (-1, x)}} else y (-1, "Sem transporte"); função y (b, c, d, e) {var k, s, t, v, x, y = c; 2! == u && (u = 2, h && a.clearTimeout (h), j = void 0, g = e || "", w.readyState = b> 0? 4: 0, k = b> = 200 && 300 > b || 304 === b, d && (v = Wb (l, w, d)), v = Xb (l, v, w, k), k? (l.ifModificado && (x = w.getResponseHeader () "Última modificação"), x && (n.lastModified [f] = x), x = w.getResponseHeader ("etag"), x && (n.etag [f] = x)), 204 === b || "HEAD" === l.type? Y = "nocontent": 304 === b? Y = "não modificado" :( y = v.state, s = v.data, t = v.erro, k =! t)): (t = y,! b && y || (y = "erro", 0> b && (b = 0))), w.status = b, w.statusText = (c || y) + "" , k? p.resolveWith (m, [s, y, w]): p.rejectWith (m, [w, y, t]), w.statusCode (r),r = void 0, i && o.trigger (k? "ajaxSuccess": "ajaxError", [w, l, k? s: t]), q.fireCom (m, [w, y]), i && (o.trigger ("ajaxComplete", [w, l]), - n.active || n.event.trigger ("ajaxStop")))} retorno w}, getJSON: function (a, b, c) {retorno n. get (a, b, c, "json")}, getScript: function (a, b) {retorno n.get (a, void 0, b, "script")}}), n.each (["get "," post "], função (a, b) {n [b] = função (a, c, d, e) {retornar n.isFunção (c) && (e = e || d, d = c, c = void 0), n.ajax (n.extend ({url: a, tipo: b, dataType: e, dados: c, sucesso: d}, n.isPlainObject (a) && a))}}), n ._evalUrl = function (a) {retornar n.ajax ({url: a, tipo: "GET", dataType: "script", cache:! 0, assíncrono:! 1, global:! 1, "lança":! 0})}, n.fn.extend ({wrapAll: function (a) {if (n.isFunction (a)) retornar this.each (function (b) {n (this) .wrapAll (a.call b))});if (this [0]) {var b = n (a, este [0] proprietárioDocument) .eq (0) .clone (! 0); this [0] .parentNode && b.insertBefore (this [0]), b .map (function () {var a = this; while (a.firstChild && 1 === a.firstChild.nodeType) a = a.firstChild; retorna a}). append (this)} retorna este}, wrapInner: function ( a) {return n.isFunction (a)? this.each (função (b) {n (this) .wrapInner (a.call (isto, b))}): this.each (function () {var b = n (this), c = b.contents (); c.length? c.wrapAll (a): b.append (a)})}, wrap: function (a) {var b = n.isFunction (a) ; return this.each (function (c) {n (this) .wrapAll (b? a.call (isto, c): a)})}, desembrulhar: function () {return this.parent (). cada ( function () {n.nodeName (this, "body") || n (this) .replaceWith (this.childNodes)}). end ()}}); função Yb (a) {retornar a.style && a.style. display || n.css (a, "display")} function Zb (a) {se (! n.contains (a.ownerDocument || d, a)) return! 0; while (a && 1 === a.nodeType) {if ("none" === Yb (a) || "oculto" === a.type) return! 0; a = a.parentNode} retornar! 1} n.expr.filters.hidden = function (a) {return l.reliableHiddenOffsets ()? a.offsetWidth <= 0 && a.offsetHeight <= 0 &&! a.getClientRects (). tamanho: Zb (a)}, n.expr.filters.visible = função (a) { return! n.expr.filters.hidden (a)}; var $ b = /% 20 / g, _b = / \ [\] $ /, ac = / \ r? \ n / g, bc = / ^ ( ?: submit | button | imagem | reset | file) $ / i, cc = / ^ (?: input | select | área de texto | keygen) / i; função dc (a, b, c, d) {var e; se (n.isArray (b)) n.each (b, function (b, e) {c || _b.test (a)? d (a, e): dc (a + "[" + ("objeto" = = typeof e && null! = e? b: "") + "]", e, c, d)}); else if (c || "objeto"! == n.type (b)) d (a, b senão para (e em b) dc (a + "[" + e + "]", b [e], c, d)} n.param = função (a, b) {var c, d = [], e = função (a, b) {b = n.isFunção (b)? b (): nula == b? "": b, d [d.length] = encodeURIComponent (a) + "=" + encodeURIComponent (b)} if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray (a) || a.jquery &&! n.isPlainObject (a)) n.each (a, function () {e (this.name, this.value)}); else para (c em a) dc (c, a [c], b, e) ; return d.join ("&"). replace ($ b, "+")}, n.fn.extend ({serializar: function () {retornar n.param (this.serializeArray ())}, serializeArray: function () {retornar this.map (function () {var a = n.prop (isso, "elementos"); retornar a? n.makeArray (a): this}). filter (function () {var a = this.type; retorne this.name &&! n (this) .is (": disabled") && cc.test (this.nodeName) &&! bc.test (a) && (this.checked ||! Z.test (a )) map (function (a, b) {var c = n (this) .val (); return null == c? null: n.isArray (c)? n.map (c, funç˜ao (a ) {return {nome: b.name, valor: a.replace (ac, "\ r \ n ")}}): {nome: b.name, valor: c.replace (ac," \ r \ n ")}}). get ()}}), n.ajaxSettings.xhr = void 0! == a.ActiveXObject? Function () {retornar this.isLocal? Ic (): d.documentMode> 8? Hc (): / ^ (get | post | head | put | delete | opções) $ / i. test (this.type) && hc () || ic ()}: hc; var ec = 0, fc = {}, gc = n.ajaxSettings.xhr (); a.attachEvent && a.attachEvent (função "onunload", ) {para (var a in fc) fc [a] (void 0,! 0)}), l.cors = !! gc && "withCredentials" em gc, gc = l.ajax = !! gc, gc && n.ajaxTransport ( function (b) {if (! b.crossDomain || l.cors) {var c; return {enviar: function (d, e) {var f, g = b.xhr (), h = ++ ec; se (g.open (b.type, b.url, b.async, b.username, b.password), b.xhrFields) para (f em b.xhrFields) g [f] = b.xhrFields [f]; b.mimeType && g.overrideMimeType && g.overrideMimeType (b.mimeType), b.crossDomain || d ["Solicitado com X"] || (d ["X-Requested-With "] =" XMLHttpRequest "); para (f in d) void 0! == d [f] && g.setRequestHeader (f, d [f] +" "); g.send (b.hasContent && b .data || null), c = função (a, d) {var f, i, j; if (c && (d || 4 === g.readyState)) if (excluir fc [h], c = void 0, g.onreadystatechange = n.noop, d) 4! == g.readyState && g.abort (); mais {j = {}, f = g.status, "string" == tipoof g.responseText && (j.text = g.responseText); tente {i = g.statusText} capturar (k) {i = ""} f ||! b.isLocal || b.crossDomain? 1223 === f && (f = 204): f = j.text? 200: 404} j && (f, i, j, g.getAllResponseHeaders ())}, b.async? 4 === g.readyState? a.setTimeout (c): g.onreadystatechange = fc [h ] = c: c ()}, abort: function () {c && c (void 0,! 0)}}}}; função hc () {try {retornar novo a.XMLHttpRequest} função catch (b) {}} ic () {try {retornar novo a.ActiveXObject ("Microsoft.XMLHTTP")} catch (b) {}} n.ajaxSetup ({aceita: {script: "texto / javascript, aplicativo / javascript, aplicativo / ecmascript, aplicativo / x-ecmascript"}, conteúdo: script {script: / \ b (?: java | ecma) \ b /}, conversores: {"script de texto": function (a) {return n.globalEval (a), a}}}), n.ajaxPrefilter ("script", função (a) {void 0 === a.cache && (a .cache =! 1), a.crossDomain && (a.type = "GET", a.global =! 1)}), n.ajaxTransport ("script", função (a) {if (a.crossDomain) {var b, c = d.head || n ("head") [0] || d.documentElement; return {enviar: function (e, f) {b = d.createElement ("script"), b.async = ! 0, a.scriptCharset && (b.charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = função (a, c) {(c ||! B.readyState || / carregado | completo / .teste (b.readyState)) && (b.onload = b.onreadystatechange = null, b.parentNode && b.parentNode.removeChild (b),b = null, c || f (200, "sucesso"))}, c.insertBefore (b, c.firstChild)}, abortar: function () {b && b.onload (void 0,! 0)}}}} var jc = [], kc = / (=) \? (? = & | $) | \? \? /; n.ajaxSetup ({jsonp: "retorno de chamada", jsonpCallback: function () {var a = jc.pop () || n.expando + "_" + Eb ++; retorne isto [a] =! 0, a}}), n.ajaxPrefilter ("json jsonp", função (b, c, d) {var , f, g, h = b.jsonp! ==! 1 && (kc.test (b.url)? "url": "cadeia" == typeof b.data && 0 === (b.contentType || "") .indexOf ("application / x-www-form-urlencoded") && kc.test (b.data) && "data"); return h || "jsonp" === b.dataTypes [0]? (e = b .jsonpCallback = n.isFunction (b.jsonpCallback)? b.jsonpCallback (): b.jsonpCallback, h? b [h] = b [h] .replace (kc, "$ 1" + e): b.jsonp! =! 1 && (b.url + = (Fb.test (b.url)? "&": "?") + B.jsonp + "=" + e), b.conversores ["script json"] = function () {return g || n.error (e + "não foi chamado"), g [0]}, b.dataTypes [0] = "json", f = a [e], a [e] = function () {g = argumentos}, d.always (function () {void 0 === f? n (a) .removeProp (e) : a [e] = f, b [e] && (b.jsonpCallback = c.jsonpCallback, jc.push (e)), g && n.isFunction (f) && f (g [0]), g = f = void 0 }), "script"): void 0}), n.parseHTML = função (a, b, c) {se (! a || "string"! = typeof a) retorna null; "boolean" == typeof b && (c = b, b =! 1), b = b || d; var e = x.exec (a), f =! c && []; return e? [b.createElement (e [1])]: (e = ja ([a], b, f), f && f.length && n (f) .remove (), n.merge ([], e.childNodes))}; var lc = n.fn.load; n. fn.load = function (a, b, c) {if ("string"! = tipo de um && lc) return lc.apply (isto, argumentos); var d, e, f, g = isto, h = a.indexOf ( ""); return h>-1 && (d = n.trim (a.slice (h, a.length)), a = a.slice (0, h)), n.isFunção (b)? (C = b, b = void 0) : b && "objeto" == typeof b && (e = "POST"), g.length> 0 && n.ajax ({url: a, tipo: e || "GET", dataType: "html", dados: b}) .done (função (a) {f = argumentos, g.html (d? n ("<div>"). append (n.paraHTML (a)). find (d): a)}). always (função c && (a, b) {g.each (function () {c.apply (isto, f || [a.responseText, b, a])})}), isto}, n.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], função (a, b) {n.fn [b] = função (a) {retornar this.on (b, a)} }), n.expr.filters.animated = função (a) {return n.grep (n.timers, função (b) {return a === b.elem}). comprimento}; função mc (a) { return n.isWindow (a)? a: 9 === a.nodeType? a.defaultView || a.parentWindow:! 1} n.offset = {setOffset: função (a, b, c) {var d, e, f, g, h, i, j, k = n.css (a, "posição"), l = n (a), m = {}; "estático" === k && (a.style.position = "relativo"), h = l.offset (), f = n.css (a, "topo"), i = n.css ( a, "left"), j = ("absoluto" === k || "fixo" === k) && n.inArray ("auto", [f, i])> - 1, j? (d = l.position (), g = d.top, e = d.left): (g = parseFloat (f) || 0, e = parseFloat (i) || 0), n.isFunção (b) && (b = b.call (a, c, n.extend ({}, h))), null! = b.top && (m.top = b.top-h.top + g), nulo! = b.left && ( m.left = b.left-h.left + e), "using" em b? b.using.call (a, m): l.css (m)}}, n.fn.extend ({deslocamento: function (a) {if (arguments.length) retornar void 0 === a? this: this.each (function (b) {noffset.setOffset (isto, a, b)}); var b, c, d = {top: 0, left: 0}, e = this [0], f = e & e.ownerDocument; if (f) retorna b = f.documentElement, n.contains (b, e)? ("! Undefined "= typeof e.getBoundingClientRect && (d = e.getBoundingClientRect ()), c = mc (f), {top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0) , left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clienteLeft || 0)}): d}, posição: function () {if (isto [0]) {var a, b, c = {top: 0, left: 0}, d = this [0], retorno "fixo" === n.css (d, "posição")? b = d.getBoundingClientRect () :( a = this. offsetParent (), b = this.offset (), n.nodeName (a [0], "html") || (c = a.offset ()), c.top + = n.css (a [0], "borderTopWidth",! 0), c.left + = n.css (a [0], "borderLeftWidth",! 0)), {superior: b.top-c.top-n.css (d, "marginTop" ,! 0), à esquerda: b.left-c.left-n.css (d, "marginLeft",! 0)}}}, offsetParent: function () {retornar this.map (function () {var a = this.offsetParent; while (a &&! n.nodeName (a, "html") && "estático" === n.css (a, "posição")) a = a.offsetParent; retorna a || Qa})}}), n.each ({scrollLeft: "páginaXOffset", scrollTop: "pageYOffset"}, função (a, b) {var = = Y / .test (b); n.fn [a] = função (d) {retorno Y (isto, função (a, d, e) {var = mc (a); retorno void 0 === e? f? b in f? f [ b): f.document.documentElement [d]: um [d]: void (f? f.scrollTo (c? n (f) .scrollLeft (): e, c? e: n (f) .scrollTop () ): a [d] = e)}, a, d, arguments.length, null)}}), n.each (["top", "left"], função (a, b) {n.cssHooks [ b] = Ua (posição, função l (pixel) {retorno c? (c = Sa (a, b), Oa.test (c)? n (a) .posição () [b] + "px ": c): void 0})}), n.each ({altura:" altura ", largura:" largura "}, função (a, b) {n.each ({return void 0 === e? f? b em f? f [b]: f.document.documentElement [d]: a [d]: void (f? f.scrollTo (c? n (f) .scrollLeft () ): e, c? e: n (f) .scrollTop ()): a [d] = e)}, a, d, argumentos.length, null)}}), n.each (["top", "left"], function (a, b) {n.cssHooks [b] = Ua (posição de l.pixel, função (a, c) {retorno c? (c = Sa (a, b), Oa.test (c )? n (a) .position () [b] + "px": c): void 0})}), n.each ({altura: "altura", largura: "largura"}, função (a, b) {n.each ({return void 0 === e? f? b em f? f [b]: f.document.documentElement [d]: a [d]: void (f? f.scrollTo (c? n (f) .scrollLeft () ): e, c? e: n (f) .scrollTop ()): a [d] = e)}, a, d, argumentos.length, null)}}), n.each (["top", "left"], function (a, b) {n.cssHooks [b] = Ua (posição de l.pixel, função (a, c) {retorno c? (c = Sa (a, b), Oa.test (c )? n (a) .position () [b] + "px": c): void 0})}), n.each ({altura: "altura", largura: "largura"}, função (a, b) {n.each ({
padding: "inner" + a, conteúdo: b, "": "outer" + a}, função (c, d) {n.fn [d] = função (d, e) {var f = arguments.length && ( c || "booleano"! = typeof d), g = c || (d ===! 0 || e ===! 0? "margin": "border"); retorno Y (isto, função (b) , c, d) {var e; return n.isWindow (b)? b.document.documentElement ["cliente" + a]: 9 === b.nodeType? (e = b.documentElement, Math.max (b) .body ["rolar" + a], e ["rolar" + a], b.body ["deslocamento" + a], e ["deslocamento" + a], e ["cliente" + a])): void 0 === dn.css (b, c, g): n.style (b, c, d, g)}, b, fd: void 0, f, nulo)}})}) , n.fn.extend ({ligar: function (a, b, c) {retornar this.on (a, null, b, c)}, desvincular: function (a, b) {retornar this.off (a, null, b)}, delegar: function (a, b, c, d) {retornar this.on (b, a, c, d)}, undelegate: function (a, b, c) {retorno 1 === arguments.length? this.off (a, "**"): this.off (b, a || "**",c)}}), n.fn.size = function () {retornar this.length}, n.fn.andSelf = n.fn.addBack, "function" == typeof define && define.amd && define ("jquery", [] , function () {return n}); var nc = a.jQuery, oc = a. $; return n.noConflict = função (b) {return a. $ === n && (a. $ = oc), b && a .jQuery === n && (a.jQuery = nc), n}, b || (a.jQuery = a. $ = n), n});